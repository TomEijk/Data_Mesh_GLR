# s 
8
## url
http://dontpanic.42.nl/2012/04/rest-and-ddd-incompatible.html
## tiny url
https://tinyurl.com/api-ddd-s8
## archive url
https://bit.ly/2z1ralB
## title
REST and DDD: incompatible?
## source code
ืno
## example
yes
## source type 
Practitioner Audience Article
## author type
Practitioner

### AXIAL CODING TRACE:
``` python
s8 = CClass(source, "s8", values={
    "title": "REST and DDD: incompatible?",
    "url": "http://dontpanic.42.nl/2012/04/rest-and-ddd-incompatible.html",
    "archive url": "https://bit.ly/2z1ralB",
    "author type": "Practitioner",
    "type": "Practitioner Audience Article",
    "example": True,
    "source code": False})
```

>REST and DDD: incompatible?
The past years, we’ve seen two new terms become popular: REST (REpresentational State Transfer) and DDD (Domain Driven Design). However, where DDD is often used to prevent an Anemic Domain (now considered an anti-pattern), a domain model for REST is often anemic. This blog post explains how we can reconcile these opposites.

**OPEN CODING TRACE:**
Refers to the domain model decision of the API. It also (with other terms) refers to the decision of API contract
vs. domain model. It refers to the option ``design the API contract considering but independent from the domain model'' where API contract is seen as an anemic domain model.

**AXIAL CODING TRACE:**
add codes to s8: 
``` python 
    '''
    domain_model_and_api, domain_model_mapping_decision, api_as_contract_decision, api_contract_specified,
    '''
```

>REST and DDD: opposites
> [SNIP] ...
> Usually this is done by modelling the domain logic inside the domain, thus preventing the anti-pattern of an Anemic Domain.
>And herein lies the rub: a set of documents is just that: data. It contains no logic. This is the opposite of a domain that contains logic.

**OPEN CODING TRACE:**
- again refers to anemic domain model in the sense above.

>Reconciling a resource model with a domain model
The core of a REST system, its Resource Model, is a collection of data on which we’ve defined CRUD operations (using GET, PUT and DELETE). Adding data is done by a POST to a list (if the primary key of the underlying data is synthetic), or using a PUT to a new URI (when the primary key of the underlying data is a natural key). In order to reconsile this with a DDD Domain Model, we must identify a domain that conforms to these verb restrictions.

**OPEN CODING TRACE:**
Refers to CRUD style mapping of domain model


**AXIAL CODING TRACE:**
add codes to s8: 
``` python 
    '''
crud_style_operations_on_resources,  operation_design_decision
    '''
```


> The first step in doing this is to reduce the number of functions to call on the domain model, by designing the domain logic to consist of data only, and not actions. Part of this can be achieved by changing actions like parcel.shipTo(location) into a property change: parcel.setLocation(location). And although it is generally not possible to remove all function calls this way, it usually suffices. Especially with a KISS attitude towards application design — with the added benefit that a simple application is easier to build and generally easier to make successful.
This KISS attitude is important, even if it is the most difficult aspect of our profession. It also helps with the final mile: CQRS

**OPEN CODING TRACE:**
- option: identify a domain that conforms to these verb restrictions (http method)
      - designing the domain logic to consist of data only, and not actions (to reduce the number of functions to call on the domain model) -> change action to property 
      - this practice involuntarily leads to the anemic domain model anti-pattern 
      (strong force against this practice)
  - KISS principle (Keep it simple stupid)
  - CQRS mentioned (but discussed in detail below)

**AXIAL CODING TRACE:**
added:
``` python
leads_to_anemic_domain_model = CClass(force, "Leads to anemic domain model anti-pattern")

``` 
add codes to s: 
``` python 
    '''
    leads_to_anemic_domain_model, api_contract_specified
     
    '''
```
- added forces encoding to new option and forces for leads_to_anemic_domain_model and simplicity
to all other forces of domain_model_mapping_decision

>A step further: CQRS
>...
At its heart, CQRS is the simple notion of using a separate model to update our domain model, and to query our domain model. The querying part is usually
easy: REST excels at this, as the decades of experience with the HTTP protocol (at least the GET requests) have resulted in a plethora of proxies, caches,
load balancers, etc. to help us with that. That leaves the update part.
>...
**OPEN CODING TRACE:**
CQRS (help to separate business logic from domain model)


**OPEN CODING TRACE:**
- mentions cqrs based api option and not using it. 
-  REST excels at this, as the decades of experience with the HTTP protocol (at least the GET requests) have resulted in a plethora of proxies, caches,
load balancers, etc. to help us with that. -> refers to scalability forces without naming it.

**AXIAL CODING TRACE:**
add codes to s8: 
``` python 
    '''
    no_cqrs_API, cqrs_API, cqrs_decision, scalability
    '''
```


>All the way: a Hyperlink API
Although our combination of REST with DDD may seem complete, it is not. It still requires an awful lot of documentation, especially for the available URI’s and in documenting the restrictions on POSTing command objects. We’re missing something.
A REST interface is not complete without links. After all, one of the tenets of REST is hyperlinking. This used to be called HATEOAS (Hypertext As The Engine Of Application State), but many simply hate the acronym. But as it essentially means that the resources of a REST interface contain hyperlinks to related resources, we really have a Hyperlink API. The best implementations resemble web pages (but are more easily interpretable by computers): they use a known format, and apart from the initial URI, all URI’s are discoverable.
Such a Hyperlink API can reduce development costs by a combination of interpreting metadata of links in a resource (so a client knows what to do with them), and delegating the interpretation of the
semantics of the links to the users. The latter is a powerful mechanism, as it reduces the amount of functionality needed.
What’s needed for such a discoverable resource model is a data format that contains links with metadata. Examples are HTML/XHTML and HAL+JSON & HAL+XML.

**OPEN CODING TRACE:**
The discussion here is on the link mapping decision. It describes the option use distributed links. 
The claim on development costs seems a bit far stretched (not argued for) but combination of interpreting metadata of links in a resource (so a client knows what to do with them), and delegating the interpretation of the semantics of the links to the users, seems to refer to reducing coupling of client and server while 
requiring higher protocol complexity in clients. 

**AXIAL CODING TRACE:**

add codes to s8: 
``` python 
    '''
    link_mapping_decision, use_distributed_links, coupling_of_clients_to_server, protocol_complexity_in_client
    '''
```

> Comment:
> Thanks for sharing your thoughts. I think that "In order to reconsile this with a DDD Domain Model, we must identify a domain that conforms to these verb restrictions." is not reconciliation. On the contrary, it is subverting DDD, which sits at the core of the application, to REST, which is part of -A- delivery mechanism. Moreover "domain logic to consist of data only" sounds very much like an anemic model, which is something we would like to avoid, not embrace. Cheers.
>

**OPEN CODING TRACE:**
confirms very negative interpretation for leads_to_anemic_domain_model force.
