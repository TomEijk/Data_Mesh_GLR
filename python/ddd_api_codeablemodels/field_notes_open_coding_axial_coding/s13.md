# s 
13
## url
https://www.ibm.com/garage/method/practices/code/domain-driven-design
## tiny url
https://tinyurl.com/api-ddd-s13
## archive url
https://bit.ly/2TDgiBJ
## title
Apply Domain-Driven Design to microservices architecture
## source code
no
## example
no
## source type 
Practitioner Audience Article
## author type
Practitioner
## references
- Domain-Driven Design: Tackling Complexity in the Heart of Software (Evans 2004)

### AXIAL CODING TRACE:
``` python
s13 = CClass(source, "s13", values={
    "title": "Apply Domain-Driven Design to microservices architecture",
    "url": "https://www.ibm.com/garage/method/practices/code/domain-driven-design",
    "archive url": "https://bit.ly/2TDgiBJ",
    "author type": "Practitioner",
    "type": "Practitioner Audience Article",
    "example": False,
    "source code": False})
add_links({s13: ddd_book_2004}, role_name="referenced")
```
# coding
>... at the beginning = microservice + ddd concept

>Which comes first: the API or the objects?

>An ongoing argument exists about which comes first: the design of your API or the design of the Objects that implement your API. Many early distributed-computing proponents advocated designing the Objects first and then making your API the same as your Object API. This approach led to problems in the granularity of the API, which often resulted in APIs that represented technical interfaces instead of business interfaces.

**OPEN CODING TRACE:**
This explains the "Which approach is chosen for defining the API contract
in relation to the domain model?" decision with its options:
Design the API contract before or independently from the domain model
Use the elements of the domain model as the elements of the API contract
(or the selected elements variant.)

>When you start with the API, you can focus on solving the business problem and avoid getting lost in the technical details of a particular implementation. Pact testing is a slightly different version of API-first. Pact is a contract unit-testing tool that ensures that services can communicate with each other.

>When you write pact tests, you unit-test the consumer and the provider separately. To test the consumer of an API, you submit an actual API request to a mock provider and receive a response. To test the provider, a mock consumer issues a request and the provider provides an actual response. Verification is done in the mocked code to ensure that the services work as expected. Testing is done only on the specific functions that the customer uses.

**OPEN CODING TRACE:**
- integration with testing -> left out
- whole discussion is also about: Separation of API contract and domain concerns

**AXIAL CODING TRACE:**
changed wording of:
``` python
add_decision_option_link(api_as_contract_decision, api_contract_specified,
                         "Design the API contract before or independently from the domain model")
``` 
add codes to s: 
``` python 
    '''
domain_model, api, entity, aggregate, api_as_contract_decision, api_contract_specified,
                 api_contract_extracted, domain_model_defines_api_contract, 
separation_of_api_contract_and_domain_concerns
    ''' 
```

>The next consideration when you design an API is whether your APIs represent Entities or Functions. The starting point for mapping is the Resource API pattern (Daigneau 2011). This pattern is a stripped-down definition of the central idea of REST. You assign all procedures and instances of domain data a URI and then use the application protocol of HTTP to define the standard service behaviors by using standard status codes wherever possible. In this model, a request consists of a URI, an HTTP server method, and optionally, and rarely, a Media type. That combination uniquely selects the particular Service that fulfills the request.

**OPEN CODING TRACE:**
Resource API pattern refers to entities or aggregates being mapped to resources (this is
mentioned before as candidates.)

>The key notion is that each URI represents a Resource, not a procedure. Resource APIs must be the bulk of the APIs that you specify. They're the rule rather than the exception.

>However, exceptions exist. The best way to handle non-entity Services is to think through the problem of "noun-ifying" them with the Process API pattern. A Process API is a reification of an action in a domain. If you can name a Service as a noun in Domain-Driven Design, that Service name becomes the URI path. A good rule is that if a paper-and-pencil version of the thing exists, it can become a resource, but if itâ€™s something a person must do, it becomes a process. An example of a process API might be processing a purchase order.

**OPEN CODING TRACE:**
Services can be mapped to resources, too.


>When you start with Domain-Driven Design, you find that the large-grained concepts that are derived through the process are closer to the right level for a good API design:

>Aggregates and Entities become Resource APIs

>Value Objects inform the design of the schema that the Resource API uses

>Services become Process APIs

**OPEN CODING TRACE:**
- entities_as_API_resources
- aggregate_roots_as_API_resources
- value object
- service -> domain_processes_as_API_resources
- <ins>Decision: </ins>  the URI path, designing_API_resources_decision
- <ins>Context: </ins> resource

**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''
    designing_API_resources_decision, entities_as_API_resources, aggregate_roots_as_API_resources,
   domain_services_as_API_resources,
    '''
# already added: 
```

> Define boundaries

> You can apply one final Domain-Domain Driven Design concept to microservices design. A Bounded Context explicitly defines the boundaries of your model. This concept is critical in large software projects. A Bounded Context sets the limits around what a specific team works on and helps them to define their own vocabulary within that particular context.

> Take the example of a customer in retail. In one context, a customer is a person who buys products from a store. In another context, a customer is a person who a retailer markets its products to. The customer is the same but is in different bounded contexts, each of which act on the customer entity based on their own rules.

> When you define a bounded context, you define who uses it, how they use it, where it applies within a larger application context, and what it consists of in terms of things like Swagger documentation and code repositories.

> In summary, when you design microservices for an application, use the principles of Domain-Driven Design to guide you along the way. Establish the Bounded Context for your team and list your Entities, Repositories, Value Objects, and Services. Then, use what you learned to define and design your microservices.
>

**OPEN CODING TRACE:** 
- explains/implies bounded contexts can be used in decision what API is offered.
 (and documented in one Swagger documentation). The Swagger documentation implies
 that bounded contexts are also the API contract granularity.

**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''
                 domain_model_mapping_decision, expose_each_bounded_context_as_an_API,
                 expose_selected_bounded_contexts_as_an_API,
                 bounded_context_defines_api_contract
    '''
# already added: 
```