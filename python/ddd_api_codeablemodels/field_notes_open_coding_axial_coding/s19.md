# s 
19
## url
https://www.calhoun.io/moving-towards-domain-driven-design-in-go/
## tiny url
https://tinyurl.com/api-ddd-s19
## archive url
https://bit.ly/3hxvSZ9
## title
Moving Towards Domain Driven Design in Go
## source code
yes
## example
yes
## source type 
Practitioner Audience Article
## author type
Practitioner
## references

**AXIAL CODING TRACE**: source and references
``` python
s19 = CClass(source, "s19", values={
    "title": "Moving Towards Domain Driven Design in Go",
    "url": "https://www.calhoun.io/moving-towards-domain-driven-design-in-go/",
    "archive url": "https://bit.ly/3hxvSZ9",
    "author type": "Practitioner",
    "type": "Practitioner Audience Article",
    "example": True,
    "source code": True})
``` 

# coding

>Moving Towards Domain Driven Design in Go
>First, letâ€™s discuss the project. Imagine that you are at work and your boss asks you to create a way to authenticate users via the GitHub API. More specifically, you are going to be given a userâ€™s personal access token, and you need to look up the user as well as all of their organizations. That way you can later restrict their access based on what orgs they are a part of.

**OPEN CODING TRACE:**
API consumer of GitHub API -> no API defined yet

> Note: I am not really using the GitHub API here - this is a mostly made up example.
> Next you to take your github package and write some middleware that can be used to protect some of our HTTP handlers. In this middleware you will retrieve a userâ€™s access token from a basic auth header and then use the GitHub code to look up the user, check to see if they are part of the provided org, then grant or deny access accordingly.

>> ...

>Luckily there is this alternative company named GitLab that seems to do a lot of the same things GitHub does, but they have a remote team. That means Godzilla can never wipe out all of their engineers, right? ðŸŽ‰

>The higher ups at your company seem to agree with this logic and they start to make the transition. Your job? You are tasked with making sure all of that authentication code you wrote works with the new system!

> You spend some time looking at the GitLab API docs, and the good news is it looks like the same overall strategy will still work. GitLab has personal access tokens, organizations, and you just need to re-implement the client. The code in the middleware shouldnâ€™t need changed at all because you were a smart cookie and you used an INTERFACE! ðŸ˜ You get to work creating the GitLab clientâ€¦

**OPEN CODING TRACE:**
Internals of the services to be defined, not API related.

>At this point you have a few options:
>Change your middleware so that the UserService interfaces expects a gitlab.User instead of a github.User
Create a new authentication middleware specifically for GitLab.
Create a common user type that will allow both your github and gitlab implementations to be interchangeable in the AuthMiddleware
(1) might make sense if you were confident that your company was going to stick with GitLab. Sure, you will need to change both the user service interface and the mocks, but if it is a one time change isnâ€™t so bad.
On the other hand, you donâ€™t really know that your org will stick with GitLab. After all, who letâ€™s Godzilla attacks dictate their decision process?
This option can also be problematic if many pieces of code throughout your application are reliant on the github.User type returned by this package.
(2) would work, but it seems a bit silly. Why would we want to rewrite ALL of that code and all of those tests when none of the logic is changing? Surely there must be a way to make this interface thing work as you originally intended. After all, that middleware really doesnâ€™t care how the user is looked up as long as we have a few critical pieces of information to work with.
So you decide to give (3) a shot. You will create a User type in your mw package and then you will write an adapter to connect it with the GitLab client you created.

**OPEN CODING TRACE:**
Internals of the services to be defined, not API related.

> As you write the code, you come to another realization; because you donâ€™t really care about things like a userâ€™s ID or email you can drop those fields entirely from your mw.User type. All you need to specify here are fields you actually care about, which should make things easier to maintain and test. Neato!

>Next up you need to create an adapter, so you get to work on it.
``` 
// Package adapter probably isn't a great package name, but this is a
// demo so deal with it.
package adapter

type GitHubUserService struct {
  Client *github.Client
}

func (us *GitHubUserService) User(token string) (mw.User, error) {
  ghUser, err := us.Client.User(token)
  if err != nil {
    return mw.User{}, err
  }
  return mw.User{
    OrgIDs: ghUser.OrgIDs,
  }, nil
}

type GitLabUserService struct {
  Client *gitlab.Client
}

func (us *GitLabUserservice) User(token string) (mw.User, error) {
  glUser, err := us.Client.User(token)
  if err != nil {
    return mw.User{}, err
  }
  return mw.User{
    OrgIDs: glUser.OrgIDs,
  }, nil
}
``` 
**OPEN CODING TRACE:**
Internals of the services to be defined, not API related.

>Finding a middle ground
>...
>I actually tried doing this on one project with my HTTP handlers just to see how it turned out. Specifically, I isolated every endpoint in my web application to its own package with no external dependencies specific to my web application and ended up with packages like this:

**OPEN CODING TRACE:**
Initial example defines a few crud style resources

**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''
    operation_design_decision, crud_style_operations_on_resources
    '''
```

>In theory this idea sounded pretty cool. I could now define all of my HTTP handlers in isolation without worrying about the rest of my application. Each package could be tested easily, and when I was writing these individual pieces I found myself incredibly productive. I even had an interface named Executor, and who doesnâ€™t want an executor in their code?!?

> In practice, this idea was awful for my particular use case. Yes, there were benefits, but they werenâ€™t outweighing the cost of writing all this code. I was productive when creating the internals of the enroll and similar packages, but I spent so much time writing adapters and connecting pieces together that it crushed my productivity overall. I couldnâ€™t find a quick way to plug this into my code without needing to write a custom UserFn, LicenseFn, and I found myself writing a bunch of virtually identical variants of UserFn for every package with http handlers.

**OPEN CODING TRACE:**
Internals of the services to be defined, not API related.

>Domain Driven Design

>I have tried to avoid any confusing terms up to this point because I find that they often complicate matters rather than simplify them. If you donâ€™t believe me, go try to read any articles, books, or other resources on domain driven design (DDD). They will almost always leave you with more questions and less clarity about how to actually implement the ideas in your code.

>Iâ€™m not suggesting that DDD isnâ€™t useful, nor am I suggesting that you shouldnâ€™t ever read those books. What I am saying is that many (most?) of my readers are here looking for more practical advice on how to improve their code, not to discuss the theory of software development.

>From a practical perspective, the key benefit of domain driven design is writing software that can evolve and change over time. The best way I have discovered to achieve this in Go is to clearly define your domain types, and to then write implementations that depend upon these types. This still results in coupled code, but because your domain is so tightly linked to the problem you are solving this coupling is rarely problematic. In fact I often find that needing a clear definition of domain models to be enlightening rather than troubling.


**OPEN CODING TRACE:**
- What is defined above are entities that can turn into aggregate roots (the Domain Types)
- The example also hints add domain services being seen as Domain Types
- Derive implementation from those domain types, and following the example this implies the (REST) API
- Design can  evolve and change over time but not really discussed in an API-specific way.

**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''
    designing_API_resources_decision, entities_as_API_resources,
    aggregate_roots_as_API_resources, domain_services_as_API_resources
    '''
```

... [snip example reiterated]

>More generally speaking, coupling to a domain rather than a specific implementation allows us to stop worrying about details like:

>    Are we interacting with a microservice or a local database? We can write code with reasonable timeouts regardless of whether our user management system is a local SQL database or a microservice.
>    Do we communicate with our user API via JSON, GraphQL, gRPC, or something else? While our implementation will need to know how to communicate with the users API, the rest of our code will continue to operate the same regardless of which specific technology we are using.
>    And much moreâ€¦

>At its crux, this is what I consider to be the primary benefit of domain driven design. It isnâ€™t fancy terms, colorful graphics, or looking smart in front of your peers. It is purely about designing software that is capable of evolving to meet your ever-changing requirements.


**OPEN CODING TRACE:**
no new info related to API

> Why donâ€™t we just start here?
> The obvious followup question at this point is, â€œWhy didnâ€™t we just start with domain driven design if it is so great?â€

>Anyone with some experience using Model-View-Controller (MVC) can tell you that it is susceptible to the tight coupling. Nearly all of our application will need to depend on our models, and we just explored how that can be problematic. So what gives?

>While building from a common domain can be useful, it can also be a nightmare if misused. Domain driven design has a fairly steep learning curve; not because the ideas are particularly hard to grasp, but because you rarely learn where you went wrong in applying them until a project grows to a reasonable size. As a result, it may take a few years until you really start to grasp all the dynamics involved. I have been writing software for quite a while, and I still donâ€™t feel like I have a full grasp on all the ways things can go wrong or get complicated.

>Note: This is one of the big reasons why I have taken so long to publish this article. I was hesitant to share when, in many ways, I still donâ€™t feel like I am an expert on this topic. I ultimately decided to share because I believe others can learn from my limited understanding, and I believe this article can evolve and improve over time as I have discussions with other developers. So feel free to reach out to discuss it - jon@calhoun.io

>MVC presents you with a reasonable starting point for organizing your code. Database interacts go here (models), http handlers go here (controllers), and rendering code goes here (views). It might lead to tight coupling, but it allows you to get started pretty quickly.

>Unlike MVC, domain driven design doesnâ€™t present you with a reasonable starting point for how to organize your code. In fact, starting with DDD is pretty much the exact opposite of starting with MVC - rather than jumping right into building controllers and seeing how your models evolve, you instead have to spend a great deal of time upfront deciding what your domain should be. This likely involves mocking up some ideas and having peers review them, discussing what is/isnâ€™t right, a few iteration cycles, and only then can you dive into writing some code. You can see this in Ben Johnsonâ€™s WTF Dial project where he creates a PR and discusses the domain with Peter Bourgon, Egon Elbre, and Marcus Olsson.

>This isnâ€™t specifically a bad thing, but it also isnâ€™t easy to get right and it requires a great deal of upfront work. As a result, I often find this working best if you have a larger team where everyone needs to agree on some common domain before development can start.

>Given that I am often coding in smaller teams (or by myself), I find that my projects evolve much more naturally if I start with something simpler. Maybe that is a flat structure, maybe it is an mvc structure, or maybe it is something else entirely. I donâ€™t get too caught up in those details, as long as I am open to my code evolving. This allows it to eventually take the form of something like DDD, but it doesnâ€™t require me to start there. As I stated before, this may be harder to do with a larger org where everyone is developing the same application together, so more upfront design discussion is often merited.


**OPEN CODING TRACE:**
no new info related to API

>
>>In our sample application we did something very similar to this â€œlet it evolveâ€ concept. Every step was taken for a specific purpose; we added a UserService interface because we needed to test our authentication middleware. When we started to migrate from GitHub to GitLab we realized that our interface didnâ€™t suffice, so we explored alternative options. It is around that point that I think a more DDD approach starts to make sense and rather than guessing at what the User and UserService should look like, we have real implementations to base it off of.

>Another potential issue with starting of with DDD is that types can be defined poorly because we are often defining them before we have concrete use cases. For instance, we might decide that authenticating a user looks like this:
> 

**OPEN CODING TRACE:**
reiterates codes already coded.

> Only later we might realize that in practice every single time we authenticate a user we really want to have the user (or maybe a remember token) returned, and that by defining this interface upfront we missed this detail. Now we need to either introduce a second method to retrieve this information, or we need to alter our UserAuthenticator type and refactor any code that implements or utilizes this.

>The same thing applies to your models. Before actually implementing a github and gitlab package we might think that the only identifying information we need on a User model is an Email field, but we might later learn through implementing these services that an email address can change, and what we also need is an ID field to uniquely identify users.

>Defining a domain model before using it is challenging. We are extremely unlikely to know what information we do and donâ€™t need unless we already have a very strong grasp of the domain we are working in. Yes, this might mean that we have to refactor code later, but doing so will be much easier than refactoring your entire codebase because you defined a your domain incorrectly. This is another reason why I donâ€™t mind starting with tightly-coupled code and refactoring at a later date.

>Finally, not all code needs this sort of decoupling, it doesnâ€™t always provide the benefits it promises, and in some circumstances (eg DBs) we rarely take advantage of this decoupling.

>For a project that isnâ€™t evolving, you likely donâ€™t need to spend all the time decoupling your code. If the code isnâ€™t evolving, changes are far less likely to occur and the extra effort of preparing for them may just be wasted effort.

>Additionally, decoupling doesnâ€™t always provide the benefits it promises and we donâ€™t always take advantage of that decoupling. As Mat Ryer likes to point out, we very rarely just swap out our database implementation. And even if we do decouple everything, and even if we do happen to be in the very small minority of applications who are transitioning databases, this transition often requires a complete rethinking of how we interact with our data store; after all, a NoSQL database behaves completely differently from a SQL database and to really take advantage of either we have to write code that is specific to the database being used. The final result is that these abstractions donâ€™t always provide us with the magical, â€œthe implementation doesnâ€™t matterâ€ results that we want.

>That doesnâ€™t mean DDD canâ€™t provide benefits, but it does mean we shouldnâ€™t simply drink the Kool-Aid and expect magical results. We need to stop and think for ourselves. 


**OPEN CODING TRACE:**
no new info related to API

> In Summary

> In this article we looked firsthand at the problems encountered when code is tightly coupled, and we explored how defining domain types and interfaces can help improve this coupling. We also discussed some of the reasons why it might not be the best idea to start off with this decoupled design, and to instead let our code evolve over time.

>In the next article in this series I hope to expand upon the idea of writing Go code using domain driven design. Specifically, I want to discuss:

>    How interface tests can help ensure implementations can be interchanged without issue.
    How subdomains can also stem from different contexts.
    Ways you can visualize this all using the traditional DDD hexagon, as well as how code like a third party library might fit into the equation.

> I also want to mention that this article is by no means a hard set of rules. It is just my meager attempt at sharing some insights and ideas that have helped me improve my Go software.

**OPEN CODING TRACE:**
no new info related to API

