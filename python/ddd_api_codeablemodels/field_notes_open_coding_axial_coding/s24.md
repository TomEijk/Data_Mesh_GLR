# s24 

## url
https://medium.com/@shijuvar/building-microservices-with-event-sourcing-cqrs-in-go-using-grpc-nats-streaming-and-cockroachdb-983f650452aa
## tiny url
https://tinyurl.com/api-ddd-s24
## archive url
https://bit.ly/3odU9GO
## title
Building Microservices with Event Sourcing/CQRS in Go using gRPC, NATS Streaming and CockroachDB
## source code
yes
## example
yes
## source type 
Practitioner Audience Article
## author type
Practitioner
## references

**AXIAL CODING TRACE**: source and references
``` python
s24 = CClass(source, "s24", values={
    "title": "Building Microservices with Event Sourcing/CQRS in Go using gRPC, NATS Streaming and CockroachDB",
    "url": "https://medium.com/@shijuvar/building-microservices-with-event-sourcing-cqrs-in-go-using-grpc-nats-streaming-and-cockroachdb-983f650452aa",
    "archive url": "https://bit.ly/3odU9GO",
    "author type": "Practitioner",
    "type": "Practitioner Audience Article",
    "example": True,
    "source code": True})
``` 
> In this post, I will demonstrate a simple Event Sourcing/CQRS Example in Go to demonstrate how to solve the practical challenges of Microservices based distributed systems. Keep in mind that my objective of this post is not about introducing best practices for Event Sourcing and CQRS, but introduce these two architectural patterns by writing a simple example in Go, which provides a solution for the challenges in Microservices based distributed systems in order to dealing with transactions and data.
The Hardest Part of Microservices: Data and Transactions
People who have never worked on distributed systems, have been misinterpreting that Microservices are just about running services in Docker containers and orchestrating it with Kubernetes. In my country, India, a lot of people have been providing corporate training and guidance on Microservices with two misinterpretations: Microservices are just about orchestrating containers with Kubernetes, or just about using Spring Boot framework with Netflix OSS. But in practice, Microservices, is a distributed systems architecture pattern that is all about functional decomposition for building highly scalable and evolvable software systems. In a nutshell, microservices are small, autonomous services that work together.
Data is scattered in several databases owned by Microservices
A common practice to decomposes Microservices is to design each Microservice against a bounded context, which is a central pattern in Domain-Driven Design (DDD), which provides logical separation of business problem into various sub domains by dividing a large domain model into different bounded contexts. A single bounded context will have one or many aggregate, and you make transactions against aggregates. Because we typically build Microservices against each bounded contexts, we typically use individual databases for each Microservices where each Microservice looks like an independent system.
Because we broke up a monolithic system into several autonomous services, the data is scattered amongst several databases owned by individual Microservices. This makes lot of complexity to your applications and architecture. For example, a business transaction may span into multiple Microservices. Let’s say you build an e-commerce system with microservices where placing an order would be initially handled by OrderService — a Microservice, then payment processing might be done by another service — a PaymentService, and so on. And another challenge is querying data from multiple databases. With a monolithic database, you can easily perform join queries from a single database. Because the monolithic database is moved into several databases as part of the decomposition of functional components, you can’t simply execute join queries, thus you must get data from multiple databases. Here you don’t have any centralized database.

**OPEN CODING TRACE:**
- microservice in general and introduction to DDD
- aggregates or bounded contexts (selected?) as API resources
- separation of business problems (in the end from/between services) by bounded contexts.


**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''
    bounded_context, aggregate, separation_of_api_contract_and_domain_concerns
    '''
```

>Building Event-Driven Microservices with Event Sourcing and CQRS
In order to solve the practical challenges of Microservices, an event-driven reactive system on DDD aggregates would be a great approach. For this, I highly recommend to use Event Sourcing, which is an event-centric architecture to construct the state of an application by composing various events.
Event Sourcing: An event store of immutable log of events
Event Sourcing deals with an event store of immutable log of events, in which each log (a state change made to an object) represents an application state. An event store is like a version control system. In a microservices architecture, we can persist aggregates as a sequence of event. Events are facts, which represent some actions happened in the system. These are immutable, which can’t be changed or be retracted. The example of events in an e-Commerce system are OrderCreated, PaymentDebited, OrderApproved, OrderRejected, OrderShipped, OrderDelivered, etc.
In your Event Sourcing architecture, when you publish one event from one Microservice, other Microservices can be reactive to those events and publish another set of events. Sometimes, the sequence of events can be compared with Unix pipes. A single transaction in a Microservices based system may span into multiple Microservices where we can perform a transaction as a sequence of events by building reactive Microservices. Each state change of an aggregate can be treated as an event, which is an immutable fact about your system.
CQRS for building query model for the views of aggregates
When you make persistence as a sequence of events by using Event Sourcing, you may need an architecture approach to make queries for your Microservices because the write model (commands) are just an event store. An architecture pattern, Command Query Responsibility Segregation (CQRS) is an ideal pattern for implementing queries for your Microservices. As the name implies, CQRS segregates an application into two parts: Commands to perform an action to change the state of aggregates, and Queries to provide a query model for the views of aggregates. Although CQRS is an independent architectural pattern, we often used this with Event Sourcing as the model for commands. We may also use different databases for both write operations and query operations. This will also allows you to make highly performant query model by loading denormalised data sets into data stores of read models.

**OPEN CODING TRACE:**
- event based microservice
- cqrs, eventual consistency
- cqrs for API query views and commands via services

**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''
    cqrs, eventual_consistency_support, cqrs, no_cqrs_API, cqrs_API, cqrs_decision,

    '''
```
>An Event Sourcing/CQRS Example in Go with gRPC, NATS Streaming and CockroachDB
The example demo is available here: https://github.com/shijuvar/go-distributed-sys
I’ve simplified the example for the sake of a conceptual demo in order to simply understand things, and get some insight on how to use technologies like gRPC, NATS, etc. for building distributed systems.
NATS Streaming for messaging
In Event Sourcing architecture, when you publish one event from one Microservice, other Microservices can be reactive to those events, and publish another set of events after doing its own local transactions. A single transaction in a Microservices based system may span into multiple Microservices where we can perform a transaction as a sequence of events by building reactive Microservices. Each state change of an aggregate can be treated as an event, which is an immutable fact about your system. In order to publish events to let other Microservices know that something has happened in your system, we need to use a messaging system. In this example, we use NATS Steraming Server as the event streaming system to build event-driven Microservices. An event-driven, reactive architecture is a great choice of architecture approach for building massively scalable Microservices. If you’re not familiar on NATS and NATS Streaming, check out my articles on basic NATS here and NATS Streaming here. I consider NATS as a nervous system for building distributed systems, which I’ve been working on Go ecosystem.
>gRPC for building APIs
>In this example, the Event Store provides an API to execute commands, which is an gRPC based API. gRPC is a high performance, open-source remote procedure call (RPC) framework that can run anywhere. It enables client and server applications to communicate transparently, and makes it easier to build connected systems. gRPC is widely known as a communication protocol in Microservices. If you make inter-process communication between Microservices over an API, gRPC is a better choice. If you’re new gRPC, check out my article here.
> example...
> demo... 
> implementation example

**OPEN CODING TRACE:**
- example, demo, implementation example
- event-based operations maybe with pub/sub 
- link to high scalability 

**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''
    expose_domain_events_as_state_transitions, operation_design_decision, 
    expose_domain_events_via_feeds_or_pub_sub, scalability
    '''
```

>[SKIP] ...