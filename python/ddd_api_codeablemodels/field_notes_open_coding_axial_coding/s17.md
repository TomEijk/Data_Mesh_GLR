# s 
17
## url
https://khalilstemmler.com/articles/typescript-domain-driven-design/ddd-vs-crud-design/
## tiny url
https://tinyurl.com/api-ddd-s17
## archive url
https://bit.ly/2yxndow
## title
REST-first design is Imperative, DDD is Declarative [Comparison] - DDD w/ TypeScript
## source code
yes
## example
yes
## source type 
Practitioner Audience Article
## author type
Practitioner

## references
- Clean Architecture

### AXIAL CODING TRACE:
``` python 
s17 = CClass(source, "s17", values={
    "title": "REST-first design is Imperative, DDD is Declarative [Comparison] - DDD w/ TypeScript",
    "url": "https://khalilstemmler.com/articles/typescript-domain-driven-design/ddd-vs-crud-design/",
    "archive url": "https://bit.ly/2yxndow",
    "author type": "Practitioner",
    "type": "Practitioner Audience Article",
    "example": True,
    "source code": True})

add_links({s17: clean_architecture_2018}, role_name="referenced")

``` 
# Coding

>> [SNIP] ... intro, imperative, declarative, rest-firt design


>REST-first Design

> When we build RESTful applications, we tend to think more about designing our applications from either:

>    the database up and
>    the API calls up



**OPEN CODING TRACE:**
- this is about the options whether you should come from the DB (related to the domain model) or specify the API first

**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''
     api_as_contract_decision, api_contract_specified, api_contract_extracted,
    '''
```


> Because of this, there's a tendency to place the majority of our business logic in either controllers or services.

> You might remember from Uncle Bob's "Clean Architecture", for controllers this is definitely no-no.

> And if you read his book of the same name, you might recall the potential service-oriented fallacy of putting all the domain logic into services (hint: Anemic Domain Models).

> But this is the type of code that gets written when:

>    we want to get something up and running quickly
    we use a framework, such as Nest.js, holistically
    we want to respond to prototype apps
    we're working on small apps
    we're working on problems that are either #1 or #2 from the Hard Software Problems

> And it does suffice for a large number projects!

> However, for complex domains with complicated business rules and policies, this has the potential to become incredibly difficult to change and extend as time goes on.

>In REST-first CRUD applications, we almost solely write imperative code to satisfy business use cases. Let's take a look at what that looks like.


**OPEN CODING TRACE:**
- hint at designing RESt based apps in CRUD style
- overall the option to write the API code first is discussed, leading to low initial effort but
might lead to maintainability issues (extend) and modifiablility problems.
- mentions anmenic domain model force

**AXIAL CODING TRACE:**
added:
``` python 
    '''
     api_code_first = CClass(practice, "Write API code first which defines the contract")

    initial_effort_required = CClass(force, "Initial Effort Required")

    add_decision_option_link(api_as_contract_decision, api_code_first,
                         "Write the API code first and design the API contract as you code the API")


add_force_relations({{api_contract_specified: {separation_of_api_contract_and_domain_concerns: positive,
                                              api_stability: positive,
                                              domain_model_flexibility: positive,
                                              initial_effort_required: neutral,
                                              api_modifiability: neutral,
                                              maintainability_of_api_and_consumers: neutral,
                                              },
                     api_contract_extracted: {separation_of_api_contract_and_domain_concerns: positive,
                                              api_stability: positive,
                                              domain_model_flexibility: positive,
                                              initial_effort_required: neutral,
                                              api_modifiability: neutral,
                                              maintainability_of_api_and_consumers: neutral
                                              },
                     domain_model_defines_api_contract: {separation_of_api_contract_and_domain_concerns: negative,
                                                         api_stability: very_negative,
                                                         domain_model_flexibility: very_negative
                                                         },
                     bounded_context_defines_api_contract: {separation_of_api_contract_and_domain_concerns: negative,
                                                            api_stability: very_negative,
                                                            domain_model_flexibility: very_negative,
                                                            initial_effort_required: neutral,
                                                            api_modifiability: neutral,
                                                            maintainability_of_api_and_consumers: neutral
                                                            },
                     api_code_first: {separation_of_api_contract_and_domain_concerns: very_negative,
                                      api_stability: very_negative,
                                      domain_model_flexibility: very_negative,
                                      initial_effort_required: very_positive,
                                      api_modifiability: negative,
                                      maintainability_of_api_and_consumers: negative

                                      }
                     })
    
    '''
```

add codes to s: 
``` python 
    '''
     operation_design_decision, crud_style_operations_on_resources, api_code_first, 
    initial_effort_required, api_modifiability, maintainability_of_api_and_consumers,
    leads_to_anemic_domain_model
    '''
```


>REST-first code
Let’s say we were working on an application where Customers could rent Movies.

>Designing REST-first using Express.js and the Sequelize ORM, my code might look like this:
``` 
class MovieController {
  public async rentMovie (movieId: string, customerId: string) {
    // Sequelize ORM models
    const { Movie, Customer, RentedMovie, CustomerCharge } = this.models;

    // Get the raw orm records from Sequelize
    const movie = await Movie.findOne({ where: { movie_id: movieId }});
    const customer = await Customer.findOne({ where: { customer_id: customerId }});

    // 401 error if not found
    if (!!movie === false) {
      return this.notFound('Movie not found')
    }

    // 401 error if not found
    if (!!customer === false) {
      return this.notFound('Customer not found')
    }

    // Create a record which signified a movie was rented
    await RentedMovie.create({
      customer_id: customerId,
      movie_id: movieId
    });

    // Create a charge for this customer.
	  await CustomerCharge.create({
      amount: movie.rentPrice
    })

    return this.ok();
  }
}
``` 
>In this code example, we pass in a movieId and a customerId, then pull out the appropriate Sequelize models that we know we’re going to need to use. We do a quick null check and then if both model instances are returned, we’ll create a RentedMovie and a CustomerCharge.

>This is quick and dirty and it shows you just how quickly we can get things up and running REST-first.

**OPEN CODING TRACE:**
again same codes as above.


>There. It works. But there are several drawbacks.
>Lack of encapsulation
>Lack of discoverability
>Lack of flexibility

**OPEN CODING TRACE:**
- <ins>Force: </ins> 
   - encapsulation  => expose_domain_model_details_in_api
   - discoverability, flexibility => maintainability_of_api_and_consumers, api_modifiability

**AXIAL CODING TRACE:**
``` 
add codes to s: 
``` python 
    '''
    expose_domain_model_details_in_api, maintainability_of_api_and_consumers, api_modifiability
    '''
```

>In Domain Modeling, one of the primary benefits is that we eventually hit an inflection point where the declarative language for specifying business rules becomes so expressive, that it takes us no time to add new capabilities and rules.

>It also makes our business logic that much more readable, abstracting away how it gets done, and presenting more of what can get done and when it’s allowed to get done (that's not to say that the plumbing doesn't have to get laid).


**OPEN CODING TRACE:**
- <ins>Force: </ins> readable => api_understandability

**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''
    api_understandability
    '''
```

>If we were to take our previous example and look at it through DDD lenses, the controller code would probably look more like this:

```
class MovieController extends BaseController {
  private movieRepo: IMovieRepo;
  private customerRepo: ICustomerRepo;
  
  constructor (movieRepo: IMovieRepo, customerRepo: ICustomerRepo) {
    super();
    this.movieRepo = movieRepo;
    this.customerRepo = customerRepo;
  }

  public async rentMovie () {
    const { req, movieRepo, customerRepo } = this;
    const { movieId } = req.params['movie'];
    const { customerId } = req.params['customer'];

    const movie: Movie = await movieRepo.findById(movieId);
    const customer: Customer = await customerRepo.findById(customerId);

    if (!!movie === false) {
      return this.fail('Movie not found')
    }

    if (!!customer === false) {
      return this.fail('Customer not found')
    }

    // The declarative magic happens here.
    const rentMovieResult: Result<Customer> = customer.rentMovie(movie);

    if (rentMovieResult.isFailure) {
      return this.fail(rentMovieResult.error)
    } else {
      // if we were using the Unit of Work pattern, we wouldn't 
      // need to manually save the customer at the end of the request.
	  await customerRepo.save(customer);
      return this.ok();
    }
  }
}
```
>See that? Notice how much is abstracted away?

>From our controller, we no longer have to worry about:

>if the Customer has more than the max number of rented movies
if the Customer has paid their bills
billing the Customer after they rent the movie.
In following articles on Domain Entities and Aggregate Roots, we'll go into more depth on how this works.

>This is the Declarative essence of DDD. How it is done is abstracted, but the ubiquitous language being used effectively describes what the domain objects are allowed to do and when.

**OPEN CODING TRACE:**
- Discusses an approach where entities or aggregates are exposed as resources.
- This has the benefits introduced above and leads to extracted/specified API contract as hinted at, at the top.

**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''
    entity, aggregate, entities_as_API_resources, aggregate_roots_as_API_resources,
    designing_API_resources_decision
    '''
```