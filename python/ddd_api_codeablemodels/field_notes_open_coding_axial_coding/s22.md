# s22 

## url
https://medium.com/design-and-tech-co/implementing-domain-driven-design-for-microservice-architecture-26eb0333d72e
## tiny url
https://tinyurl.com/api-ddd-s22
## archive url
https://bit.ly/37vBiQW
## title
Implementing Domain-Driven Design for Microservice Architecture
## source code
no
## example
yes
## source type 
Practitioner Audience Article
## author type
Practitioner
## references

**AXIAL CODING TRACE**: source and references
``` python
s22 = CClass(source, "s22", values={
    "title": "Implementing Domain-Driven Design for Microservice Architecture",
    "url": "https://medium.com/design-and-tech-co/implementing-domain-driven-design-for-microservice-architecture-26eb0333d72e",
    "archive url": "https://bit.ly/37vBiQW",
    "author type": "Practitioner",
    "type": "Practitioner Audience Article",
    "example": True,
    "source code": False})
``` 

# coding

>Microservices is an application architectural style with a clear bounded context, interface and dependencies emerged from the Domain-Driven Design architectural patterns and DevOps; each microservice is a loosely coupled service with a single responsibility principle, where each component is a full but miniature application that’s focused on producing a single business task. The business task is meaningful to the business users — no technical or infrastructure microservices. Each has a clear interface and dependencies (such as to other microservices and external resources) so that the microservice can run relatively independently and the team can develop it reasonably independently.
Microservices make developers (not just computers) more efficient. It does so by enabling them to accomplish meaningful work (e.g., develop meaningful parts of apps) while working in small teams. Small teams make developers (and people in general) more productive because they spend less time in meetings (and otherwise communicating with and coordinating with others) and more time developing code * . And the users ultimately use the code developers write — not the meetings they attend, the architectural diagrams they draw, the status updates they send their managers. The more time developers spend writing code, the more value they’re producing for the users. (Or, if developers writing code aren’t delivering value for users, something’s wrong! Their team is dysfunctional, or they need to think about a career change!)
Before delving into the microservices design patterns; first, we need to analyze and understand the business domain (business-capabilities concept); today’s business environment is extremely complex and competitive with little to no margin for error any false decision can lead to a catastrophic outcome. Mitigating this risk is essential; thus, adopting an approach to software development for complex domains is highly recommended; Domain-Driven Design (DDD) is a software development approach around solving complex domain model; the solution revolves around the business model by connecting the implementation to the core business concepts. The common terminology between the business/domain experts and the development team are domain logic, subdomains, bounded contexts, context maps, domain models, and ubiquitous language as a way to collaborate and improve the application model and resolve any emerging domain-related issues.
Microservices are not without their drawbacks; a lack of DevOps and automation may impede your microservices initiative and could bring more pain than benefits, but this is a topic for a future blog post; meanwhile, let’s stress on the gains that the microservice architecture bring organization aside business capabilities and modular services:
Scalability
Availability
Resiliency
Independent, autonomous
Decentralized governance
Failure isolation
Auto-Provisioning
Continuous delivery through DevOps
Using the right approach to building microservices it’s more about the software’s architectural design, providing a structure of practices to take design decisions that help in software projects that have complicated domains. It focuses on the area of a specific business to gain a better understanding of what the domain is all about. One must start by modeling the business understanding and modeling the real-world problem to be solved. Domain-Driven Design is a framework based on strategic value, and it’s about mapping business domain concepts into software artifacts.
Any microservice implementation could benefit by following this prescriptive approach:
Analyze domain
Defined bounded contexts
Define entities, aggregates, and services
Identify microservices

**OPEN CODING TRACE:**
- microservice and DDD introduction

**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''
    bounded_context, aggregate, service, entity
    '''
```
>Analyze domain
A domain refers to real-world aspects of a solution (e.g., automobile, banking, mortgage, credit, debit accounts, credit cards, retails loans, content management, etc.) The domain informs the requirements and acceptance criteria for the system to be implemented by the developer; the domain can be suggestive of a very high-level form of segregation for different areas of the business. For our microservices to successfully implemented it requires a clean separation of concern by applying some boundaries as suggested by Domain-Driven Design approach:
Teams are usually working in certain business domains
The business domain is the core focus of the team
The granularity of a domain depends on the position of a team in the organization
The Domain model captures concepts and processes for a specific business domain and require a deep understanding of the field in question, so the best way to accomplish these requirements is through Event Storming; Event Storming is a workshop-based method to find out what is happening in the domain quickly. The process starts from the context of events happening in a domain and looks at events as fundamental elements in a model.

**OPEN CODING TRACE:**
- mentioning event storming

>...[SKIP] strategic and tactical DDD explanation...

> Identify microservices
Step 4 (Identify microservices) comprises of Microservice architecture, Microservices architecture layers, Back ends for front ends, Asynchronous communication and Microservices intercommunication to name a few to help write a Microservices based application.
Microservice architecture
We define a set of bounded contexts for a microservices application. Then we looked more closely at one of these bounded contexts, the Change management bounded context, and identified a set of entities, aggregates, and domain services for that bounded context by doing so we can define an architecture that structures the application as a set of loosely coupled, collaborating services. Each service implements a set of narrowly, related functions. For example, an application might consist of services such as the order management service, the customer management service, etc.

**OPEN CODING TRACE:**
- suggestions to expose (maybe selected) bounded contexts as services / in apis.
- relation to coupling

>
>Services communicate using either synchronous protocols such as HTTP/REST or asynchronous protocols such as AMQP (Advanced Message Queuing Protocol). Services can be developed and deployed independently of one another. Each service has its database to be decoupled from other services. Data consistency between services is maintained using the Saga pattern.

**OPEN CODING TRACE:** 
- data consistency force mentioned

>As the services are very granular, client applications usually need to interact with multiple services to get the data they need. To allow changes in the services without affecting the clients, an API Gateway is used. The API Gateway is an abstract layer that hides away all the microservices, leaving a single endpoint for clients to communicate. Requests coming to the gateway will be proxied/routed to the appropriate services. The gateway can also help us to monitor the usage of the services efficiently. *
Microservice, a component in this architecture:
Each is a miniature application
Each is focused on one task, a business capability (The Single Responsibility principle: Each microservice implements only one business responsibility from the bounded domain context. From a software point of view, the system needs to be decomposed into multiple components where each component becomes a microservice. Microservices have to be lightweight, in order to facilitate smaller memory footprints and faster startup times.)
Each can be deployed and updated independently
They are loosely coupled
Each has a well-defined interface: REST APIs

**OPEN CODING TRACE:**
- the context is more about DDD and microservice with the use of API
- again link to bounded context per service (business capability) and loose coupling
- Figures 4+5 contain examples on this again.

**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''
    domain_model_mapping_decision,
    expose_bounded_contexts_as_APIs, expose_selected_bounded_contexts_as_an_API,
    coupling_of_clients_to_server, data_consistency
    '''
```

>... [SKIP] DDD and microservice