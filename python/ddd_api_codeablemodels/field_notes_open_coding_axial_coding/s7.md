# s 
7
## url
https://threedots.tech/post/ddd-lite-in-go-introduction/
## tiny url
https://tinyurl.com/api-ddd-s7
## archive url
https://bit.ly/3hhN58x
## title
Introduction to DDD Lite: When microservices in Go are not enough
## source code
True
## example
True
## source type 
Practitioner Audience Article
## author type
Practitioner

**AXIAL CODING TRACE:**
``` python
s7 = CClass(source, "s7", values={
    "title": "Introduction to DDD Lite: When microservices in Go are not enough",
    "url": "https://threedots.tech/post/ddd-lite-in-go-introduction/",
    "archive url": "https://bit.ly/3hhN58x",
    "author type": "Practitioner",
    "type": "Practitioner Audience Article",
    "example": True,
    "source code": True})
```
## references

**AXIAL CODING TRACE:**
``` python
  add_links({s7:ddd_book_2004}, role_name="referenced")
```
## Coding:

> [SNIP] ... skipping long introduction and intro on DDD

**OPEN CODING TRACE:**
```
- <ins>Comments: </ins>
 - the author points out language and age of code matter for migrate the lagacy system to the DDD concept. He also mentioned the organization level, it means policy of the company matters.
 - this article => GO + micro service + tested'-based approach  + DRY principle
- Discussion of relation of Strategic vs. Tactical Domain-Driven Design patterns

```
**AXIAL CODING TRACE:**
- no action taken yet.
> DDD Lite in Go

> After a pretty long introduction, it’s finally time to touch some code! In this article, we will cover some basics of Tactical Domain-Driven Design patterns in Go. Please keep in mind that this is just the beginning. There will be a couple more articles needed to cover the entire topic.

> [SNIP] ... next part introduces 3 rules about how to map DDD to go, nothing API specific
>
> To not make this article long, let’s just introduce the Repository interface and assume that it’s working. 😉 I will cover this topic more in-depth in the next article.

**OPEN CODING TRACE:**
```
 - repository mentioned
```
**AXIAL CODING TRACE:**
``` python
# EVE added 21.07.2020
'''repository'''
``` 

> Using domain objects
>
>

> I did a small refactor of our gRPC endpoints, to provide an API that is more “behavior-oriented” rather than CRUD. It reflects better the new characteristic of the domain. From my experience, it’s also much easier to maintain multiple, small methods than one, “god” method allowing us to update everything.

```
--- a/api/protobuf/trainer.proto
+++ b/api/protobuf/trainer.proto
@@ -6,7 +6,9 @@ import "google/protobuf/timestamp.proto";
 
 service TrainerService {
   rpc IsHourAvailable(IsHourAvailableRequest) returns (IsHourAvailableResponse) {}
-  rpc UpdateHour(UpdateHourRequest) returns (EmptyResponse) {}
+  rpc ScheduleTraining(UpdateHourRequest) returns (EmptyResponse) {}
+  rpc CancelTraining(UpdateHourRequest) returns (EmptyResponse) {}
+  rpc MakeHourAvailable(UpdateHourRequest) returns (EmptyResponse) {}
 }
 
 message IsHourAvailableRequest {
@@ -19,9 +21,6 @@ message IsHourAvailableResponse {
 
 message UpdateHourRequest {
   google.protobuf.Timestamp time = 1;
-
-  bool has_training_scheduled = 2;
-  bool available = 3;
 }
 
 message EmptyResponse {}

Full source: github.com/ThreeDotsLabs/wild-workouts-go-ddd-example/commit/0249977c58a310d343ca2237c201b9ba016b148e#diff-15fd9ad3f3992b0210090109b82c5594
```

> The implementation is now much simpler and easier to understand. We also have no logic here - just some orchestration. Our gRPC handler now has 18 lines and no domain logic!

```
func (g GrpcServer) MakeHourAvailable(ctx context.Context, request *trainer.UpdateHourRequest) (*trainer.EmptyResponse, error) {
   trainingTime, err := protoTimestampToTime(request.Time)
   if err != nil {
      return nil, status.Error(codes.InvalidArgument, "unable to parse time")
   }

   if err := g.hourRepository.UpdateHour(ctx, trainingTime, func(h *hour.Hour) (*hour.Hour, error) {
      if err := h.MakeAvailable(); err != nil {
         return nil, err
      }

      return h, nil
   }); err != nil {
      return nil, status.Error(codes.Internal, err.Error())
   }

   return &trainer.EmptyResponse{}, nil
}
```



**OPEN CODING TRACE:**
Describes a refactoring from CRUD-like operations to domain operations.

Text refers to maintainability of API and characteristics of the domain -> i.e. better API understandability.
then again to understandability and maintainability through simplicity.

**AXIAL CODING TRACE:**
added codes:
``` python
'''
entity, aggregate, domain_model, value_object,
                 operation_design_decision, crud_style_operations_on_resources, domain_operations_on_resources,
                 api_understandability, maintainability_of_api_and_consumers'''
```


>No more Eight-thousanders

> As I remember from the old-times, a lot of Eight-thousanders was actually controllers with a lot of domain logic in HTTP controllers.

>With hiding complexity inside of our domain types and keeping rules that I described, we are preventing uncontrolled growth in this place.
That’s all for today

>I don’t want to make this article too long – let’s go step by step!

> If you can’t wait, the entire working diff for the refactor is available on GitHub. In the next article, I’ll cover one part from the diff that is not explained here: repositories.

> Even if it’s still the beginning, some simplifications in our code are visible.

> The current implementation of the model is also not perfect – that’s good! You will never implement the perfect model from the beginning. It’s better to be prepared to change this model easily, instead of wasting time to make it perfect. After I added tests of the model and separated it from the rest of the application, I can change it without any fear.

**OPEN CODING TRACE:**
refers to domain logic maybe exposed to API (and the controller in first place), and again maintainability.

**AXIAL CODING TRACE:**
added codes:
``` python
    expose_domain_model_details_in_api
```




