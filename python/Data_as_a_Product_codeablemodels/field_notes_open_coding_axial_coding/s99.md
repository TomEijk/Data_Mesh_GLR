# s 
99
## url
https://nhpatt.com/bounded-context-in-apis/
## tiny url
https://tinyurl.com/api-ddd-s1
## archive url
https://bit.ly/2BsvnjK
## title
Bounded Context in APIs (1/2)
## source code
no
## example
no
## source type 
Practitioner Audience Article
## author type
Practitioner

**AXIAL CODING TRACE:**
``` python
s1 = CClass(source, "s1", values={
    "title": "Bounded Context in APIs (1/2)",
    "url": "https://nhpatt.com/bounded-context-in-apis/",
    "archive url": "https://bit.ly/2BsvnjK",
    "author type": "Practitioner",
    "type": "Practitioner Audience Article",
    "example": False,
    "source code": False})

ddd_vernon_book_2013 = CClass(reference, "vernon2013implementing", values={
    "bibliographic reference": "Vernon, Vaughn: Implementing domain-driven design}" + "Addison-Wesley Professional, 2013",
    "author type": "Practitioner",
    "type": "Practitioner Book"})
add_links({s_example: ddd_vernon_book_2013}, role_name="referenced")
  ```

> This is an open question: Does it makes sense to expose the bounded contexts (from DDD) in your REST APIs?

**OPEN CODING TRACE:**

Option: Expose Bounded Context in API

this is not REST specific, would be the same question in grpc API, so removed REST here.

This is about how to map the domain model to the API; the context of the decision is the domain model.

**AXIAL CODING TRACE:**
added: 
``` python
expose_bounded_context_in_API = CClass(practice, "Expose Bounded Context in API")

domain_model_mapping_decision = CClass(decision, "How to map a domain model and its elements to an API?")

add_links({domain_model_mapping_decision: domain_model_and_api}, role_name="context",
          stereotype_instances=decide_for_some_instances_of)
```

as from the further text it is possible to add each or selected bounded contexts to APIs, derived two subclasses 
for those options:

``` python
  expose_each_bounded_context_as_an_API = CClass(practice, "Expose Each Bounded Context as an API",
                                               superclasses=expose_bounded_contexts_as_APIs)
  expose_selected_bounded_context_as_an_API = CClass(practice, "Expose Selected Bounded Contexts as APIs",
                                                   superclasses=expose_bounded_contexts_as_APIs)

```
> I think that the answer is a categorical NO. But there are colleagues that disagree so I have tried to first, gather a mountain of evidence and then second, to try to reason about it offering use cases that prove my point.

**OPEN CODING TRACE:**
Other Option: Do not expose Bounded Context in API. But this is too generic. Other options (good and bad ones) are listed in the text below.

**AXIAL CODING TRACE:**
- details follow below


> The maybe most? second-most after the original book? famous book about DDD dedicates a chapter to integration of DDD and external systems, like REST APIs.
> Tempting though it may be, it is not advisable to directly expose a domain model via RESTful HTTP.
> This approach often leads to system interfaces that are more brittle than they need to be, as each change in the domain model is directly reflected in the system interface. There are two alternative approaches for combining DDD and RESTful HTTP.

**OPEN CODING TRACE:**
"expose domain model as API" is similar, and indeed an option that practitioners use, but there are a number of downsides listed here, especially:

- system interfaces that are more brittle than they need to be, as implementation details are exposed
- api modifiability is negatively influenced if domain model is exposed (because of brittle interface)
-> applies also to Expose Bounded Context in API

-> this refers to "Implementing Domain-Driven Design" by Vernon

> If we have defined a domain model in our backend, exposing it in a 1:1 relationship is a bad idea.

**OPEN CODING TRACE:**
This points at two options here: expose the whole domain model 1:1 or a subset of it.

**AXIAL CODING TRACE:**
added:

``` python
expose_domain_model_as_API = CClass(practice, "Expose the whole Domain Model in 1:1 Relation as API")
expose_domain_model_subset_as_API = CClass(practice, "Expose Domain Model Subset as API")

add_decision_option_link(domain_model_mapping_decision, expose_domain_model_as_API,
                         "Map domain model fully to the API")
add_decision_option_link(domain_model_mapping_decision, expose_domain_model_subset_as_API,
                         "Map selected elements of the domain model to the API")

#- added: 
brittle_interface = CClass(force, "Brittle interfaces"),
expose_domain_model_details_in_api = CClass(force, "Expose domain model details in API")
```

> The first approach is to create a separate Bounded Context for the system’s interface layer (..). This can be deemed a classic approach, as it views the system’s interface as a cohesive whole that is simply exposed using resource abstractions instead of services or remote interfaces.

**OPEN CODING TRACE:**
-> another option: create a separate Bounded Context for the system’s interface layer

**AXIAL CODING TRACE:**
added:
``` python
introduce_and_expose_interface_bounded_context_in_API = CClass(practice,
                                                               "Introduce and Expose Interface Bounded Context as an API",
                                                               superclasses=expose_bounded_contexts_as_APIs)

add_decision_option_link(domain_model_mapping_decision, introduce_and_expose_interface_bounded_context_in_API,
                         "Introduce and expose an additional interface Bounded Context in API")
```                                                             

> I like this approach: the domain in the interface is the web page/mobile app you are trying to render by REST calls. You are inside the same bounded context (that could cover several ones in your domain layer). That way you simplify the life of the frontend developer, you minimize REST calls and don’t expose directly your domain.

**OPEN CODING TRACE:**
positive aspects of the approach:

- less complexity, more usability of API
- minimize API calls

**AXIAL CODING TRACE:**
``` python
#- added:  
api_complexity = CClass(force, "API Complexity")
api_usability = CClass(force, "API Usability")
minimize_api_calls = CClass(force, "Minimize API calls")
```
> Another approach is appropriate when more emphasis is placed on standard media types. (...) a domain model can be created to represent each standard media type. Such a domain model might even be reused across clients and servers, although some REST and SOA proponents view this as an anti-pattern.

> Note: Such an approach is essentially a Shared Kernel (3) or Published Language (3) in DDD terms.

**OPEN CODING TRACE:**
 Another option: Shared Kernel  for API
-> related to / similar to separate Bounded Context for the system’s interface layer

**AXIAL CODING TRACE:**
added:
``` python 
shared_kernel_as_API = CClass(practice, "Expose a Shared Kernel between Client and Server as an API")
add_decision_option_link(domain_model_mapping_decision, shared_kernel_as_API,
                         "Identify shared kernel between communication participants and expose it as an API")

add_force_relations({expose_domain_model_as_API: {brittle_interface: very_negative,
                                                  expose_domain_model_details_in_api: negative,
                                                  api_complexity: very_negative,
                                                  api_usability: negative,
                                                  minimize_api_calls: negative,
                                                  api_modifiability: negative},
                     expose_domain_model_subset_as_API: {brittle_interface: neutral,
                                                         expose_domain_model_details_in_api: neutral,
                                                         api_complexity: neutral,
                                                         api_usability: neutral,
                                                         minimize_api_calls: negative,
                                                         api_modifiability: negative},
                     expose_each_bounded_context_as_an_API: {brittle_interface: negative,
                                                             expose_domain_model_details_in_api: negative,
                                                             api_complexity: negative,
                                                             api_usability: negative,
                                                             minimize_api_calls: negative,
                                                             api_modifiability: negative},
                     expose_selected_bounded_context_as_an_API: {brittle_interface: neutral,
                                                                 expose_domain_model_details_in_api: neutral,
                                                                 api_complexity: neutral,
                                                                 api_usability: neutral,
                                                                 minimize_api_calls: negative,
                                                                 api_modifiability: neutral},
                     interface_bounded_context_as_API: {brittle_interface: positive,
                                                        expose_domain_model_details_in_api: positive,
                                                        api_complexity: positive,
                                                        api_usability: positive,
                                                        minimize_api_calls: positive,
                                                        api_modifiability: positive},
                     shared_kernel_as_API: {brittle_interface: positive,
                                            expose_domain_model_details_in_api: positive,
                                            api_complexity: positive,
                                            api_usability: positive,
                                            minimize_api_calls: positive,
                                            api_modifiability: positive},
                     })
```

> Coming from a REST background… I don’t know what to think about this approach. The book uses the ical format as an example, but what if the media type that best represents my use case is only application/json? and creating new media types for the interface use cases sounds very fishy.

**OPEN CODING TRACE:**
this seems to refer only to the media types (rest specific part), not the Shared Kernel  for API option -> ignore this for now.
 


> Thoughtworks: REST API design resource modeling

> This blog post talks a lot about a real use case (that coincidentally applies to my domain): rendering blog posts.

> It is very important to distinguish between resources in REST API and domain entities in a domain driven design. Domain driven design applies to the implementation side of things (including API implementation) while resources in REST API drive the API design and contract. 

> API resource selection should not depend on the underlying domain implementation details.

> Quite clear IMHO. Resources != domain entities. This blog post continues talking about several approaches:

>A blog post API (to create a new blog post entry) can be designed in two ways. 

>The first approach is to design multiple APIs - one each for blog post (title & textual content), picture / attachments, tags on the content / picture, etc. This approach makes APIs more fine grained resulting in chattier interactions between the API consumer and provider. This approach will require API consumers to make multiple API requests to the server. The server will end up receiving a significantly higher number of HTTP requests - possibly impacting its ability to serve multiple API consumers.
>

**OPEN CODING TRACE:**
This is about resource modelling (not API level). That is, one resource per entity and sometimes per aggregate are 
options that would lead to such chatty APIs. It is also about designing the operations CRUD-style, which is another 
aspect.

Mentioning of API contract and separation of API contract and domain internals. Hints at decision on 
API contract design; but no details here.


Negative aspects: chatty API, performance, scalability

**AXIAL CODING TRACE:**
added: 
``` python
entities_as_API_resources = CClass(practice, "Entities API Resources")
designing_API_resources_decision = CClass(decision,
                                          "Which domain model elements should be offered as resources " +
                                          "or endpoints in an API?")

add_decision_option_link(designing_API_resources_decision, entities_as_API_resources,
                         "Offer entities as API resources") 
add_links({designing_API_resources_decision: identified_interface_elements}, role_name="context",
          stereotype_instances=decide_for_some_instances_of)
                                                       
crud_style_operations_on_resources = CClass(practice, "CRUD-style operations on resources")
operation_design_decision = CClass(decision,
                                   "How to design the operations of a resource?")
add_decision_option_link(operation_design_decision, crud_style_operations_on_resources,
                         "Design operations like primitive datastore operations")
add_links({operation_design_decision: operation}, role_name="context",
          stereotype_instances=decide_for_all_instances_of)

 
chatty_api = CClass(force, "Chatty API")
performance = CClass(force, "Performance")
scalability = CClass(force, "Scalability")
 
add_force_relations({crud_style_operations_on_resources: {expose_domain_model_details_in_api: negative,
                                                          chatty_api: very_negative,
                                                          performance: very_negative,
                                                          scalability: very_negative},
                     domain_operations_on_resources: {expose_domain_model_details_in_api: positive,
                                                      chatty_api: positive,
                                                      performance: positive,
                                                      scalability: positive},
                     })

separation_of_api_contract_and_domain_concerns = CClass(force, "Separation of API contract and domain concerns")

api_as_contract_decision = CClass(decision,
                                  "Which approach is chosen for defining the API contract " +
                                  "in relation to the domain model?")
add_links({api_as_contract_decision: api_contract}, role_name="context",
          stereotype_instances=decide_for_some_instances_of)


```                    
>The second approach is to design a coarse grained API for posting a blog (to “Posts” collection resource) that can include post title, post content, picture and tags. This requires making just one API request to the API provider reducing the load on the server.

**OPEN CODING TRACE:**
This is about resource modelling with aggregates or selected aggregates, maybe even bounded contexts. It is also about
more coarse grained, explicit domain operation design.

**AXIAL CODING TRACE:**
added: 
``` python
aggregate_roots_as_API_resources = CClass(practice, "Aggregate Roots as API Resources")
bounded_contexts_as_API_resources = CClass(practice, "Bounded Contexts as API Resources")
domain_operations_on_resources = CClass(practice, "Domain operations on resources")

add_decision_option_link(designing_API_resources_decision, aggregate_roots_as_API_resources,
                         "Offer aggregate roots as API resources")
add_decision_option_link(designing_API_resources_decision, bounded_contexts_as_API_resources,
                         "Offer bounded contexts as API resources")
add_decision_option_link(operation_design_decision, domain_operations_on_resources,
                         "Design coarser grained, explicit domain operations")
```
> (...)

> If the API consumers are expected to directly manipulate the low level resources (using fine grained APIs), like CRUD, there will be two big outcomes: Firstly, the API consumer to API provider interactions will be very chatty. Secondly, business logic will start spilling over to the API consumer.

**OPEN CODING TRACE:**
Again: Negative aspects: chatty API, performance, scalability
Additionally: Negative aspect: domain logic exposed to client

**AXIAL CODING TRACE:**
added: 
``` python
add_force_relations({entities_as_API_resources: {expose_domain_model_details_in_api: very_negative,
                                                 chatty_api: negative,
                                                 performance: negative,
                                                 scalability: negative},
                     aggregate_roots_as_API_resources: {expose_domain_model_details_in_api: positive,
                                                        chatty_api: positive,
                                                        performance: positive,
                                                        scalability: positive},
                     bounded_contexts_as_API_resources: {expose_domain_model_details_in_api: positive,
                                                         chatty_api: positive,
                                                         performance: positive,
                                                         scalability: positive},
                     })
```

> So thoughtworks is slightly against chattier approaches. This can be seen from 2 fronts: don’t force frontend users to cross bounded contexts (that will make you do another request call) and think in your frontend use cases to create bounded contexts that cover your interfaces (again, I’m completely in favour of this).

**OPEN CODING TRACE:**
Post also seems to confirm earlier decision, options and forces, as in this paragraph.


> Stack Overflow: Why the domain model should not be used as resources in REST API?

>Why the domain model should not be used as resources in REST API?

> When using DDD, the REST API should always be separated from the domain model.

>The main reason for this is simplification - you don't want to leak the complexity of the domain model through the API to the clients. Otherwise, clients need to know about the nuances and intricacies of your domain, which most probably makes the API hard to use.

> Because the web is a totally different world than your core domain layer. (...) If you want to expose your application via REST, you have to shoehorn your domain processes into HTTP and that usually means making compromises and designing resources that are different from your domain entities.

> Again, web world priorities: fewer API calls, linked resources are NOT the same as your domain layer.

**OPEN CODING TRACE:**
Seems to confirm earlier decision, options and forces.

Emphasises linked resources. This and its embedded alternative are described in the two API patterns:

https://www.microservice-api-patterns.org/patterns/quality/referenceManagement/LinkedInformationHolder

https://www.microservice-api-patterns.org/patterns/quality/referenceManagement/EmbeddedEntity

(embedded entity not mentioned here, but we know that it is the alternative in this decision from our prior pattern studies ...)

The implicit alternative: use object identifiers that are passed in the payload. This and to 
a smaller extend maybe embedded entities might leak domain info to the client.

also referred to with "minimize" force above -> but this is a different decision on how to map links.

embedded variant better for minimizing calls, but larger payload (message size). 
linking better for consistency, evolvability, modifiability properties of the web. see also related pattern descriptions.

**AXIAL CODING TRACE:**
added: 
``` python
# https://www.microservice-api-patterns.org/patterns/quality/referenceManagement/LinkedInformationHolder
linked_information_holder = CClass(pattern, "Linked Information Holder")
# https://www.microservice-api-patterns.org/patterns/quality/referenceManagement/EmbeddedEntity
embedded_entity = CClass(pattern, "Embedded Entity")
# from remoting patterns:
object_identifier = CClass(pattern, "Object Identifier")

use_distributed_links = CClass(practice, "Use distributed or hypermedia links in the payload")
pass_object_ids = CClass(practice, "Pass object identifiers in the payload")
embed_linked_data = CClass(practice, "Embed linked data in the payload")


use_distributed_links_uses_linked_information_holder = \
    use_distributed_links.add_links(linked_information_holder, role_name="to", stereotype_instances=uses)[0]
pass_object_ids_uses_object_id = \
    pass_object_ids.add_links(object_identifier, role_name="to", stereotype_instances=uses)[0]
embed_linked_data_uses_embedded_entity = \
    embed_linked_data.add_links(embedded_entity, role_name="to", stereotype_instances=uses)[0]


link_mapping_decision = CClass(decision, "How to map links between domain model elements to the API?")
do_nothing_for_links = CClass(do_nothing_design_solution)
add_decision_option_link(link_mapping_decision, do_nothing_for_links,
                         "Do not offer the link via the API")
add_decision_option_link(link_mapping_decision, use_distributed_links,
                         "Pass distributed or hypermedia links in the payload to represent domain model links")
add_decision_option_link(link_mapping_decision, pass_object_ids,
                         "Pass object identifiers in the messages to represent domain model links")
add_decision_option_link(link_mapping_decision, embed_linked_data,
                         "Pass embedded data in the messages to include perhaps needed data")
add_links({link_mapping_decision: domain_model_element_link}, role_name="context",
          stereotype_instances=decide_for_some_instances_of)


add_force_relations({use_distributed_links: {data_consistency: positive,
                                                 api_evolvability: positive,
                                                 api_modifiability: positive,
                                                 message_size: very_positive,
                                                 expose_domain_model_details_in_api: very_positive,
                                                 minimize_api_calls: negative,
                                                 performance: negative,
                                                 scalability: negative},
                     pass_object_ids: {data_consistency: positive,
                                         api_evolvability: positive,
                                         api_modifiability: positive,
                                         message_size: very_positive,
                                         expose_domain_model_details_in_api: negative,
                                         minimize_api_calls: negative,
                                         performance: negative,
                                         scalability: negative},
                     embed_linked_data: {data_consistency: negative,
                                       api_evolvability: negative,
                                       api_modifiability: negative,
                                       message_size: negative,
                                       expose_domain_model_details_in_api: neutral,
                                       minimize_api_calls: positive,
                                       performance: positive,
                                       scalability: positive},
                     })
```
> More SO: How to clearly define boundaries of a bounded context

> Another Stack Overflow question, modeling a country selector:

> If your different bounded contexts understand the meaning/purpose of a country differently, then you need to model it appropriately different in each one. 

>However, if we are speaking simply of reference data of ISO codes and names, then I believe it's pretty fair and standard to stash it wherever is convenient and make it accessible to all interested parties. For example: a database, a configuration file, a web service, etc.

> This sounds like shared kernel to me :)

**OPEN CODING TRACE:**
-> confirmation for shared kernel option

>GOTO 2015 • DDD & REST - Domain Driven APIs for the Web • Oliver Gierke

> A really good talk that mentions two good points:

>    Aggregates (several domain models) are good resource candidates.

**OPEN CODING TRACE:**
confirmation of the aggregate root option

>    Use Hypermedia :P

**OPEN CODING TRACE:**
-> again link to LinkedInformationHolder as an alternative to represent links

https://www.microservice-api-patterns.org/patterns/quality/referenceManagement/LinkedInformationHolder

> A blog post: REST and DDD: incompatible?

> Not a very meaty blog post that can be resumed in a one-liner: use hypermedia.
>

**OPEN CODING TRACE:**
-> again link to LinkedInformationHolder as an alternative to minimize calls

https://www.microservice-api-patterns.org/patterns/quality/referenceManagement/LinkedInformationHolder

> Final words

> This should be it, right? We shouldn’t expose our domain layer in our REST API. That means that the bounded contexts of DDD shouldn’t carry over to our REST resources. We should define another and share crossover concepts with a Shared Kernel approach.

**OPEN CODING TRACE:**
summary of the decision above

> This is what I think, focusing on what I think are frontend priorities, as a mobile developer I heavily do NOT want to make several API calls to fill out a screen (and that’s one of the main reasons GraphQL is so popular these days).

> I’m up for defining the business use cases of each frontend screen/app but, under those pretenses, we should try to minimize HTTP calls.
>

**OPEN CODING TRACE:**
-> again emphasis on "minimize HTTP calls" force and the link to LinkedInformationHolder decisions