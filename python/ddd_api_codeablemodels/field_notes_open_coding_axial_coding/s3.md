# s 
3
## url
https://stackoverflow.com/questions/33970716/why-the-domain-model-should-not-be-used-as-resources-in-rest-api
## tiny url
https://tinyurl.com/api-ddd-s3
## archive url
https://bit.ly/2Z1D5dh
## title
Why the domain model should not be used as resources in REST API?
## source code
yes
## example
yes
## source type 
Practitioner Audience Article
## author type
Practitioner

**AXIAL CODING TRACE:**
``` python
s3 = CClass(source, "s3", values={
    "title": "Why the domain model should not be used as resources in REST API?",
    "url": "https://stackoverflow.com/questions/33970716/why-the-domain-model-should-not-be-used-as-resources-in-rest-api",
    "archive url": "https://bit.ly/2Z1D5dh",
    "author type": "Practitioner Audience Article",
    "type": "Practitioner",
    "example": True,
    "source code": True})
``` 
## references

# coding

## post1 (main)
>I came across a statement that the domain model designed in accordance with DDD should not be used as resources in a REST API (source).

**OPEN CODING TRACE:**
refers to domain model and how it should get mapped as a whole to an API, either as a whole or subsets are possible.

**AXIAL CODING TRACE:**
add codes to s3: 
``` python 
    '''
    domain_model, domain_model_mapping_decision, expose_domain_model_as_API, expose_domain_model_subset_as_API, 
    '''
```
>It is clear that a REST API is a contract of the application while the domain model is part of the implementation and therefore it is the best to keep these two things separate, so that a change in the domain model does not automatically imply a change in the REST API.

**OPEN CODING TRACE:**
api modifiability is negatively influenced if domain model is exposed (because of mismatch contract/implementation or model)

api contract, separation of contract force, and related decision mentioned

if domain model is exposed, API contract == domain model

**AXIAL CODING TRACE:**
added: 
``` python 
domain_model_defines_api_contract = CClass(practice, "Domain model defines API contract")

add_decision_option_link(api_as_contract_decision, domain_model_defines_api_contract,
                         "Use the elements of the domain model as the elements of the API contract")

domain_model_defines_api_contract_can_be_realized_with_1_1_domain_model = \
    domain_model_defines_api_contract.add_links(expose_domain_model_as_API,
                                                role_name="to", stereotype_instances=can_be_realized_with)[0]

domain_model_defines_api_contract_can_be_realized_with_domain_model_subset = \
    domain_model_defines_api_contract.add_links(expose_domain_model_subset_as_API,
                                                role_name="to", stereotype_instances=can_be_realized_with)[0]
```

add codes to s3: 
``` python 
    '''api_modifiability,             api_contract,
            separation_of_api_contract_and_domain_concerns,
            api_as_contract_decision'''
```

>However, I think in case of small projects (where the REST API has just one consumer - the javascript frontend, developed by one team) the benefits of having separate models does not justify the cost of separating the models (different classes - domain model and resource representations and mapping code between the models). Obviously the domain layer cannot have any references to REST specific infrastructure code (to keep separation of concerns).


**OPEN CODING TRACE:**
there is an extra design and implementation effort for adding another layer between interface and domain model implementation

**AXIAL CODING TRACE:**
added:
``` python
design_and_implementation_effort = CClass(force, "Design and Implementation Effort")
```

added resulting force relations:
``` python
add_force_relations({expose_domain_model_as_API: {...
                                                  design_and_implementation_effort: positive},
                     expose_domain_model_subset_as_API: {...
                                                         design_and_implementation_effort: positive},
                     expose_each_bounded_context_as_an_API: {...
                                                             design_and_implementation_effort: positive},
                     expose_selected_bounded_context_as_an_API: {...
                                                                 design_and_implementation_effort: positive},
                     interface_bounded_context_as_API: {...
                                                        design_and_implementation_effort: negative},
                     shared_kernel_as_API: {...
                                            design_and_implementation_effort: negative},
                     })
```

add codes to s3: 
``` python 
    '''design_and_implementation_effort, '''
```


>Should the domain and the REST models be separated?

## post2
>When using DDD, the REST API should always be separated from the domain model.

>The main reason for this is simplification - you don't want to leak the complexity of the domain model through the API to the clients. Otherwise, clients need to know about the nuances and intricacies of your domain, which most probably makes the API hard to use.

**OPEN CODING TRACE:**
- this refers to the expose_domain_model_details_in_api force in domain_model_mapping_decision
- we have two options for doing this: interface_bounded_context_as_API, shared_kernel_as_API

>And the main driver for using DDD is a complex problem domain, so this is always a problem.

>However, I think in case of small projects (…) the benefits of having separate models does not justify the cost of separating the models (…).

>I agree that there are projects where a separated domain model and REST API is over-engineering. However, these cases aren't candidates for DDD, because you will not benefit from DDD enough to justify its cost.

**OPEN CODING TRACE:**
again, refers to to design and implementation effort.

**AXIAL CODING TRACE:**
add codes to s3: 
``` python 
    '''expose_domain_model_details_in_api, domain_model_mapping_decision, interface_bounded_context_as_API, shared_kernel_as_API'''
```

  
## post3
>Why the domain model should not be used as resources in REST API?

>Because the web is a totally different world than your core domain layer. The methods in your entities are especially hard to translate since HTTP only has a handful of verbs. If you want to expose your application via REST, you have to shoehorn your domain processes into HTTP and that usually means making compromises and designing resources that are different from your domain entities.

**OPEN CODING TRACE:**
this refers to the combination of expose_domain_model_as_API or expose_domain_model_subset_as_API and then 
crud_style_operations_on_resources. This would mean for the API contract mentioned in post 1 that only the subset 
defines the contract.
A new force on interface design limits domain model design is discussed.

**AXIAL CODING TRACE:**
add: 
``` python 
    interface_design_limits_domain_model_design = CClass(force, "Interface Design Limits Domain Model Design")

    api_contract_extracted = CClass(practice, "Extract API contract from domain model")

    add_decision_option_link(api_as_contract_decision, api_contract_extracted,
                             "Design the API contract by selecting elements of the domain model to be exposed")

    api_contract_extracted_can_be_realized_with_domain_model_subset = \
        api_contract_extracted.add_links(expose_domain_model_subset_as_API,
                                         role_name="to", stereotype_instances=can_be_realized_with)[0]
```
add codes to s3: 
``` python 
    '''operation_design_decision, crud_style_operations_on_resources, interface_design_limits_domain_model_design,
    api_contract_extracted, api_contract_extracted_can_be_realized_with_domain_model_subset
    '''
```
added new force relations:
``` python
add_force_relations({crud_style_operations_on_resources: {...
                                                          interface_design_limits_domain_model_design: negative},
                     domain_operations_on_resources: {...
                                                      interface_design_limits_domain_model_design: positive},
                     expose_domain_events_as_state_transitions: {...
                                                                 interface_design_limits_domain_model_design: positive},
                     expose_domain_events_via_feeds_or_pub_sub: {...
                                                                 interface_design_limits_domain_model_design: positive},
                     })

```

>Of course you should find terms from the Ubiquitous Language in the messages exchanged between the HTTP client and server and in the Domain Application Protocol if you're doing HATEOAS, but the web will necessarily distort your domain representations.

**OPEN CODING TRACE:**
this refers to using domain operations on resources (which can be coarse grained operations or events in our model so far)

**AXIAL CODING TRACE:**
add codes to s3: 
``` python 
    '''domain_operations_on_resources, expose_domain_events_as_state_transitions'''
```

>The point of REST is not to re-create a high fidelity model of your domain and its processes, but to deliver them in an HTTP compliant way while losing as little as possible in translation. Yet it remains a translation.


## post4

>I think another thing to consider is who uses your REST API. If you are developing an frontend for an app then you could say that everything is still happening within 1 bounded context. Just some part lives in client/javascript. In that case i think it does make sense to expose your model in your rest api.

**OPEN CODING TRACE:**
This refers to expose_each_bounded_context_as_an_API or expose_selected_bounded_context_as_an_API and sees 
expose_domain_model_as_API or expose_domain_model_subset_as_API as alternatives in some cases. New force on
having to cross boundaries in the model on client side, which is negative if API covers bounded contexts, but 
can be positive if all relevant models are mapped to API. Even better when dedicated interface layer.

Note for the API contract decision from Post 1, this means the bounded context exposed defines the contract.

**AXIAL CODING TRACE:**
add: 
``` python 
    interface_design_limits_domain_model_design = CClass(force, "Interface Design Limits Domain Model Design")

bounded_context_defines_api_contract = CClass(practice, "Bounded context defines API contract")

add_decision_option_link(api_as_contract_decision, bounded_context_defines_api_contract,
                         "Use the elements of a bounded context as the elements of the API contract")

bounded_context_defines_api_contract_can_be_realized_with_bounded_context_apis = \
    bounded_context_defines_api_contract.add_links([expose_each_bounded_context_as_an_API,
                                                    expose_selected_bounded_context_as_an_API],
                                                   role_name="to", stereotype_instances=can_be_realized_with)[0]

```
add codes to s3: 
``` python 
    '''clients_need_to_manage_crossing_model_boundaries, expose_domain_model_as_API, expose_domain_model_subset_as_API,
    expose_domain_model_subset_as_API, expose_selected_bounded_context_as_an_API, bounded_context,
    bounded_context_defines_api_contract, bounded_context_defines_api_contract_can_be_realized_with_bounded_context_apis'''
```
added new force relations:
``` python
add_force_relations({expose_domain_model_as_API: {...
                                                  clients_need_to_manage_crossing_model_boundaries: positive,
                                                  ...},
                     expose_domain_model_subset_as_API: {...
                                                         clients_need_to_manage_crossing_model_boundaries: positive,
                                                         ...},
                     expose_each_bounded_context_as_an_API: {...
                                                             clients_need_to_manage_crossing_model_boundaries: negative,
                                                             ...},
                     expose_selected_bounded_context_as_an_API: {...
                                                                 clients_need_to_manage_crossing_model_boundaries: negative,
                                                    ...},
                     interface_bounded_context_as_API: {...
                                                        clients_need_to_manage_crossing_model_boundaries: very_positive,...},
                     shared_kernel_as_API: {...,
                                            clients_need_to_manage_crossing_model_boundaries: very_positive,
                                        },
                     })

```

>in that case the REST api might just be a means of communication with your domain services for example.

## post5
>You can hook your business logic into your REST resources based on your domain model. For example, whenever someone sets is_published = 1 you can notify an admin, do extra validation, etc by hooking into an event or a mutator. Sometimes things may be too complicated and weird to do that way, so you can flag certain attributes as unmodifiable then create custom actions to modify them that you expose, if that makes sense. I think that if you design properly you don't even need these "custom actions" though. Facebook doesn't use any with the Graph API I don't think. I'm thinking about developing a framework based around just exposing the Model layer, I still think it's a good idea.

**OPEN CODING TRACE:**
details on expose_domain_model_as_API

## post6
>I think the main benefit of REST APIs is providing a service for (typically server side and not SPA) 3rd party REST clients. If you use HATEOAS and other self-descriptive message solutions like RDF, then the REST clients will break a lot harder due to changes in the REST API. For small projects - "where the REST API has just one consumer - the javascript frontend, developed by one team" - I don't think it's worth the effort to have a proper REST API. Most people use the simplified version of it, which I call CRUD API, those might be good for these projects.

**OPEN CODING TRACE:**
refers to crud_style_operations_on_resources vs. using linked_information_holders


>There can be an 1 to 1 mapping between the CRUD resources and the domain objects of an anaemic domain model. If we are talking about real objects (instead of data structures) with more than just CRUD methods, then you have to translate between resource.verb and object.method, for example:

>POST /dogs/{id}/barking
 -> domain.dog.bark()

**OPEN CODING TRACE:**
refers to domain_operations_on_resources

>If we are talking about more complex things involving multiple domain objects and unit of work (transactions), then you need to add another layer for the application services, otherwise you would move the whole complex operation including the transaction handling to the client. In those cases you translate between resource.verb and applicationService.operation for example:

>POST /dogs/{id1,id2,..}/barking
 -> dogService.multiDogBark(...)
 -> UnitOfWork{domain.dogs[ids[i]].bark()}
>
**OPEN CODING TRACE:**
refers to interface layer like interface_bounded_context_as_API

Note: this means for API contract decision mentioned in Post 1 that the API contract is designed in this interface bounded context
(same applies to the similar Shared Kernel Option)

I think most of the developers confuse this CRUD services + anaemic domain model approach with the REST services + domain model approach, that's why this question is asked and that's why there are many "REST" frameworks which add 1:1 domain object - CRUD resource mapping or maybe even ORM entity - CRUD resource mapping. I find this trend very destructive and I think the main cause that developers learn certain technologies only superficially from short articles or Q&A sites instead of reading books and dissertations where they can get deep knowledge in the actual topic. I think this is an Y+ generation problem, that we are losing the ability to read long texts because of the usage of the digital technology. We are conditioned to instant rewards instead of the delayed reward a long text gives...

**OPEN CODING TRACE:**
probably refers to the negative forces of the different involved decisions, but no details.


**AXIAL CODING TRACE:**
added:
``` python 

api_contract_specified = CClass(practice, "Explicitly specify the API contract")

add_decision_option_link(api_as_contract_decision, api_contract_specified,
                         "Design the API contract considering but independent from the domain model")

api_contract_specified_can_be_realized_with_interface_bounded_context_or_shared_kernel = \
    api_contract_specified.add_links([interface_bounded_context_as_API, shared_kernel_as_API],
                                     role_name="to", stereotype_instances=can_be_realized_with)[0]

```

add codes to s3: 
``` python 
    '''interface_bounded_context_as_API,domain_model_mapping_decision, operation_design_decision, entity,
    crud_style_operations_on_resources, domain_operations_on_resources, linked_information_holders, link, 
    use_distributed_links,  use_distributed_links_uses_linked_information_holder,
    link_mapping_decision,             api_contract_specified,
            api_contract_specified_can_be_realized_with_interface_bounded_context_or_shared_kernel,'''
```