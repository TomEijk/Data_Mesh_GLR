# s 
31
## url
https://tanzu.vmware.com/application-modernization-recipes/app-architecture/api-first-development
## tiny url
https://tinyurl.com/api-ddd-s31
## archive url
https://bit.ly/2W36EZS
## title
API First Development
## source code
yes
## example
yes
## source type 
Practitioner Audience Article
## author type
Practitioner
## references


**AXIAL CODING TRACE**: source and references
``` python
s31 = CClass(source, "s31", values={
    "title": "API First Development",
    "url": "https://tanzu.vmware.com/application-modernization-recipes/app-architecture/api-first-development",
    "archive url": "https://bit.ly/2W36EZS",
    "author type": "Practitioner",
    "type": "Practitioner Audience Article",
    "example": True,
    "source code": True})
``` 




>An extension of “Design-First” methodology is “Contract-First” where the developer defines the contract of the API before the implementation is coded. Just-in-time and just-enough design is critical to agility. Applying design-first / contact-first methodology to the world of API development results in “API-First” development. The basic idea is that you create an API contract before implementing the full code and plumbing. The human-readable API specification becomes the quick first deliverable that allows fast, quick feedback from various stakeholders. These rapid iterations are a game changer because changing the API specification takes minutes not hours or days! Once the team determines that the API specification is “good enough” a full maven Spring Boot Application can be generated. Many other languages are supported as well – more on that later. The developer codes the business logic implementation in the server stub. While the developer is coding, the QA teams can be handed the spec as well so they get a head start on service testing.
API First with Open API Spec 2.0
>
>
**OPEN CODING TRACE:**
- API contract first practices and specifying the API contract.
- API understandability

**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''api_as_contract_decision, api_contract_specified, api_contract_specified_first, api_understandability
    '''
```

>The Open API Specification is a language and vendor neutral API specification standard. There are many permutations of tools, technologies, languages to approach API design and development, most new server-side development happens in the Java programming language. This document will walk through a real world scenario of putting ‘API-First in Practice’ with Open API for the first time. The goal is to provide a clear path to achieving agile API development and being effective at it.

>Read about the Open API Initiative.
>API-First Development Workflow

>There are 4 high-level steps:

>    Create API
    Collaborate
    Generate Server
    Deploy to Cloud

>API Dev Flow

>The first step is essentially starting the API development using Open API Spec 2.0. Begin working on evolving and iterating the API specification by collaborating with the product owner, service consumers and other stakeholders. Once the team is comfortable that the API specification is 'good enough' - generate the server in Spring Boot. Deploy the app to the cloud or locally. At this point the round-trip engineering starts. All updates to the API in the code automatically updates the API specification that is co-deployed via annotations.
>
**OPEN CODING TRACE:**
- API modifiability and stability related arguments

**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''api_modifiability, api_stability
    '''
```


>Step 1: Create the API

>Use Open API 2.0 specification standard and the YAML format to describe the API as follows:

>The high-level context of the API:
[skip example]

>You can start the Open API 2.0 Editor here It will start up with an example. Alternatively, you can import another YAML specification - see the YAML specifications in the references section.
Step 2: Evolve the API (Collaborate)

>As the API is developing - the specification file can and should be shared with other collaborators for review. The main idea is to ensure that the paths and models are good enough. In other words, you don't want to strive for perfection rather a few brief meetings with the stakeholders to ensure that there is a common understanding and consensus. The idea is that API-first allows for rapid iterations without changing the code/plumbing in the initial phases.

**OPEN CODING TRACE:**
- mentions initial effort, api evolvability

**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''api_evolvability, initial_effort_required
    '''
```


>The first-cut of the API spec should minimally have the RESTful paths, responses and high level response objects. The API should be small-enough that it fits within a person’s head. Of course, good understanding of domain driven design, API design, REST design and Open API spec is required.

>This design spec can save you hours of implementation and refactoring effort in the plumbing of the code. This allows subject matter experts to discuss the API and make changes. Quality engineers can get involved and begin early test design and development. Architects can begin to think about system architecture implications on sourcing of data. Data analysts can begin thinking about data fields and standards alignment where appropriate. This spec should become the camp fire across which multiple teams can gather to discuss the API and make changes.
>Step 3: Generate Server Stub (Spring Boot Scaffolding)

>To further accelerate the API development process, go ahead and use the API Editor to Generate the Server. Alternatively a command line tool can be used.

>A 'Spring Boot' server gets generated along with a Maven pom file and it's dependencies. A compressed zip file with all the scaffolding code for the API is downloaded.

>Generate Spring Server Generation

>This can be expanded and imported as a Maven project. The parent pom should be updated. Package names should be renamed to match the needs of the service.

>Spring Boot

>The project already contains a Maven pom file and a Spring Boot project with dependencies. it can be run as-is and deployed - it just works. Open a command terminal mvn spring-boot:run .
Step 4: Implement and Deploy

>When you run the Spring Boot API - you will see the Annotations have been added to the code - and they show up via the api-docs and also the swagger ui.

>Spring API Docs

>This api is a JSON format that represents the exact YAML file that was written. Going forward as the code is changed to evolve the shape of the API and it's implementation, SpringFox annotations in the code will always keep the API in sync. If new API end-points are added to this or new verbs - the developer is expected to use the annotations. This should be simple because the API interface class already has annotations and following the same conventions over time will be much easier.

>Swagger UI and JSON code
>[FIGURES IN THE TEXT]


**OPEN CODING TRACE:**
- Local object IDs used for links
- parts of hyperref links passed
- some things that could be links are embedded

**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''link_mapping_decision, pass_object_ids, linked_information_holder, use_distributed_links, object_identifier, do_nothing_for_links
    '''
```

>A user-friendly and interactive Web-Page is generated automatically (Swagger UI). This allows for a quick execution of the API - the web-form allows for data to be entered directly and this allows the API to be tested quickly by any user without any special tools or technology skillsets.
Conclusion

>There are many permutations of tools, technologies, languages and methods that try to approach API design and development. Weeks of microservices coding can save you hours of API designing. The goal is to provide a clear path to achieving API-First development and being effective at it. API-First Development practice as outlined in this document is effective and economical.



**OPEN CODING TRACE:**
- technical details, reiterations, summary




