# s 
6
## url
https://stackoverflow.com/questions/35700344/rest-api-and-ddd/35708211
## tiny url
https://tinyurl.com/api-ddd-s6
## archive url
https://bit.ly/2ydDqz0
## title
Rest API and DDD
## source code
True
## example
True
## source type 
Discussion Forum Post
## author type
Practitioner

**AXIAL CODING TRACE:**
s6 = CClass(source, "s6", values={
    "title": "Rest API and DDD",
    "url": "https://stackoverflow.com/questions/35700344/rest-api-and-ddd/35708211",
    "archive url": "https://bit.ly/2ydDqz0",
    "author type": "Practitioner",
    "type": "Discussion Forum Post",
    "example": True,
    "source code": True})

## references

**AXIAL CODING TRACE:**
  - add codes to s1:
  - add_links({s1:}, role_name="referenced")

# POST 1:

> In my project using DDD methodology.
> The project has the aggregate(entity) Deal. This aggregate has many of use cases.
> For this aggregate I need to create a rest api.

**OPEN CODING TRACE:**
Question of a design decision: How to map DDD concepts like aggregate or entity to RESTful APIs?

**AXIAL CODING TRACE:**
added codes:
``` python
entity, aggregate, designing_API_resources_decision, aggregate_roots_as_API_resources
```
> With standard: create and delete no problem.

> 1) CreateDealUseCase(name, price and many another params);

> POST /rest/{version}/deals/
>{ 
>   'name': 'deal123',
>   'price': 1234;
>   'etc': 'etc'
>}

**OPEN CODING TRACE:**
Solution of the design decision: If create method on DDD aggregate -> map to POST request calling the collection URL

Very detailed/REST-oriented.
Abstract view of this: use crud style operations

**AXIAL CODING TRACE:**
added codes:
``` python
operation_design_decision, crud_style_operations_on_resources
```
> 2) DeleteDealUseCase(id)
> 
> DELETE /rest/{version}/deals/{id}

**OPEN CODING TRACE:**

Solution of the design decision: If delete method on DDD entity in aggregate -> map to DELETE request to collection element URL

Implicit decision here: uses URL scheme:

base_url/collection_name
base_url/collection_name/collection_element_name

-> collection_name for aggregates
-> collection_element_name for entities in the aggregate

Very detailed/REST-oriented.
Abstract view of this: use crud style operations

>But what to do with the rest of the use cases?

>    HoldDealUseCase(id, reason);
>    UnholdDealUseCase(id);
>    CompleteDealUseCase(id, and many another params);
>    CancelDealUseCase(id, amercement, reason);
>    ChangePriceUseCase(id, newPrice, reason);
>    ChangeCompletionDateUseCase(id, newDate, amercement, whyChanged);
>    etc(total 20 use cases)...

> What are the solutions?

> 1) Use verbs:

>PUT /rest/{version}/deals/{id}/hold
>{ 
>   'reason': 'test'
>}
>But! Verbs can not be used in the url(in REST theory).

**OPEN CODING TRACE:**
Solution, for data-changing operations on collection elements unclear. Probably the same for all entities 
It is clear, PUT must be used. But how to specify the kind of data change?

Possible solution use a verb in the URL scheme:

base_url/collection_name/collection_element_name/verb_indicating_the_change

and changed data as payload.

Unclear: are verb violation REST principles?

Very detailed/REST-oriented.
Abstract view of this: one option to map to domain operations

**AXIAL CODING TRACE:**
added codes:
``` python
domain_operations_on_resources
```


> 2) Use the completed state(which will be after the the use case):
> 
>PUT /rest/{version}/deals/{id}/holded
> { 
>   'reason': 'test'
>}
>Personally for me it looks ugly. Maybe I'm wrong?

**OPEN CODING TRACE:**
Same as above, but use wording to indicate state after change

Judged as UGLY == not an elegant solution.

Very detailed/REST-oriented.
Abstract view of this: another option to map to domain operations


> 3) Use 1 PUT request for all operations:
> 
> PUT /rest/{version}/deals/{id}
>{ 
>   'action': 'HoldDeal',
>   'params': {'reason': 'test'}
>}
>
>PUT /rest/{version}/deals/{id}
>{ 
>   'action': 'UnholdDeal',
>   'params': {}
>}

**OPEN CODING TRACE:**
Same as above, but different Solution: encode action to be performed in the payload and have just one PUT method for 
all collection elements under "base_url/collection_name/collection_element_name"

Very detailed/REST-oriented.
Abstract view of this: new option encoding the operation in the payload. It is a variant of explicit domain
operations.

**AXIAL CODING TRACE:**
added:
``` python
encode_operations_as_commands_in_the_payload = CClass(practice, "Encode operations as commands in the payload")

add_decision_option_link(operation_design_decision, encode_operations_as_commands_in_the_payload, 
                         "Group operations on resource and select operations in the payload")

encode_operations_variant_of_domain_operations_on_resources = \
    domain_operations_on_resources.add_links(encode_operations_as_commands_in_the_payload, role_name="to",
                                             stereotype_instances=variant)[0]
```

added codes:
``` python
encode_operations_as_commands_in_the_payload, encode_operations_variant_of_domain_operations_on_resources, 

```

copied forces from domain_operations_on_resources to encode_operations_as_commands_in_the_payload


> It is difficult to handle in the backend. Moreover, it is difficult to document. Since 1 action has many different variants of requests, from which is already dependent on specific responses.

> All solutions have significant drawbacks.

> I have read many articles about the REST on the internet. Everywhere only a theory, how to be here with my specific problem?

**OPEN CODING TRACE:**
Question: are any of those good solutions?

A maintainability force is mentioned. Downgrade maintainability_of_api_and_consumers to neutral in the variant.

Difficulty to document refers to api understandability. new force.

**AXIAL CODING TRACE:**
add: 
``` python 
api_understandability = CClass(force, "API understandability")
```



setting forces:
``` python
add_force_relations({crud_style_operations_on_resources: {...
                                                          api_understandability: positive,
                                                          },
                     domain_operations_on_resources: {...
                                                      api_understandability: positive,
                                                      },
                     encode_operations_as_commands_in_the_payload: {...
                                                                    api_understandability: negative,
                                                                    },
                     expose_domain_events_as_state_transitions: {...
                                                                 api_understandability: negative,
                                                                 },
                     expose_domain_events_via_feeds_or_pub_sub: {...
                                                                 api_understandability: negative,
                                                                 },
                     })
```


added codes:
``` python
maintainability_of_api_and_consumers, api_understandability

```

# Post 2

> Based on what I see here, you really need to watch at least one of Jim Webber's talks on REST and DDD
>
>    Rest in Practice
>    Domain Driven Design for RESTful Systems

> Ignore the API for a moment - how would you do it with HTML forms?

> You'd presumably have a web page the presents a representation of Deal, with a bunch of links on it. One link would take you to the HoldDeal form, and another link would take you to the ChangePrice form, and so on. Each of those forms would have zero or more fields to fill in, and the forms would each post to some resource to update the domain model.

> Would they all post to the same resource? Perhaps, perhaps not. They would all have the same media type, so if they were all posting to the same web endpoint, you would have to decode the content on the other side.

> Given that approach, how do you implement your system? Well, the media type wants to be json, based on your examples, but there really isn't anything wrong with the rest of it.

**OPEN CODING TRACE:**
Design advice: design REST API for DDD entities / aggregates in a similar structure you would design HTML forms navigation and processing for the same data

Mentions implicitly options about mapping an entity or an aggregate to a resource.

**AXIAL CODING TRACE:**

added codes:
``` python
entities_as_API_resources, aggregate_roots_as_API_resources, designing_API_resources_decision,
```

>    1) Use verbs:

>That's fine.

**OPEN CODING TRACE:**
verb solution from above judged as being a valid solution, no new code/option

>    But! Verbs can not be used in the url(in REST theory).

>Um... no. REST doesn't care about the spelling of your resource identifiers. There's a bunch of URI best practices that claim that verbs are bad - that's true - but that's not something that follows from REST.

>But if people are being so fussy, you name the endpoint for the command instead of the verb. (ie: "hold" isn't a verb, it's a use case).

**OPEN CODING TRACE:**
- common misconception about RESTful URI schemes that verb cannot be used in the URL
- yes, some sources are not fond of verbs in REST
- verb can be a use case identifier, too

=> downside of this solution: there can be confusion with simple verb mapping in OO

very REST-specific, no new code/option

**AXIAL CODING TRACE:**
-

>    Use 1 PUT request for all operations:

> Honestly, that one isn't bad either. You won't want to share the URI though (because of the way the PUT method is specified), but use a template where the clients can specify a unique identifier.

**OPEN CODING TRACE:**
Solution 3 is judged as valid as well

-> Solution 2 from above not mentioned, i.e. it is not good.

very REST-specific, no new code/option

**AXIAL CODING TRACE:**
-

> Here's the meat: you are building an API on top of HTTP and HTTP methods. HTTP is designed for document transfer. The client gives you a document, describing a requested change in your domain model, and you apply the change to the domain (or not), and return another document describing the new state.

> Borrowing from the CQRS vocabulary for a moment, you are posting commands to update your domain model.

**OPEN CODING TRACE:**
- Practice in solution 3 (maybe also 1) related to CQRS pattern

-> option to use (or not cqrs in api)

- Alternative name for Solution 2: posting commands to update your domain model

-> add link between practices

**AXIAL CODING TRACE:**
added:
``` python
    cqrs_API_can_use_encode_operations_as_commands_in_the_payload = \
    cqrs_API.add_links(encode_operations_as_commands_in_the_payload, role_name="to", stereotype_instances=can_use)[0]

```
added codes:
``` python
cqrs, cqrs_API, cqrs_api_use_cqrs, no_cqrs_API, cqrs_decision, 
cqrs_API_can_use_encode_operations_as_commands_in_the_payload
```



> PUT /commands/{commandId}
> { 
>   'deal' : dealId
>   'action': 'HoldDeal',
>   'params': {'reason': 'test'}
> }
>

**OPEN CODING TRACE:**
variant of Solution 2 where the ID is coded in the payload as well

-> only about details of payload

**AXIAL CODING TRACE:**
-
    


> Justification - you are putting a specific command (a command with a specific Id) into the command queue, which is a collection.

> PUT /rest/{version}/deals/{dealId}/commands/{commandId}
>{ 
>   'action': 'HoldDeal',
>   'params': {'reason': 'test'}
>}

> Yeah, that's fine too.

**OPEN CODING TRACE:**
- Another variant for Solution 3: where command gets an ID and is named in payload 

**AXIAL CODING TRACE:**
-
    


> Take another look at RESTBucks. It's a coffee shop protocol, but all of the api is just passing small documents around to advance the state machine.

**OPEN CODING TRACE:**
example from S2, studied there already.

**AXIAL CODING TRACE:**
-

> I seem that you invented the remote procedure calls based on REST. – xfg Jun 19 '17 at 10:17

**OPEN CODING TRACE:**
Solution  3 (and 1?) has RPC feel

>But what if you dont want to build 20 endpoints that would follow the behavior of domain model? 20 endpoint is extremely difficult to maintain. What if you have one endpoint and an additional layer between application and domain layers that would compare and process posted data in order to trigger proper domain behaviour? – mko Oct 9 '17 at 11:45

**OPEN CODING TRACE:**
Drawback: Solution 3 can be complex for many endpoints

-> but other solutions are complex in other ways. not a good point to distinguish the solutions at the more abstract level

**AXIAL CODING TRACE:**
-



>>The complexity exists either way. You either put it in the rest client or in the server. In the server you reduce the places your domain rules are. – JDPeckham May 8 '19 at 12:34

**OPEN CODING TRACE:**
is there a less complex solution at all

-> cofirms point above

# POST 3:

> Design your rest api independently of the domain layer.

**OPEN CODING TRACE:**
in comments this is explained further:

>Domain-driven design is about domain. API clients should be designed with domain in mind too. Otherwise you lose most of benefits of DDD. – Eugene Griaznov Dec 6 '16 at 10:47

> Yeah but that doesn't mean you should expose all the complexity of your domain to the consumers of the API. The API could expose a subset of the functionalities of the domain layer for example. – Kaidjin Dec 6 '16 at 14:43

**OPEN CODING TRACE:**
In summary:

Solution: Design your rest api as subset of the domain layer
Hide all unnecessary domain complexity.

**AXIAL CODING TRACE:**

added codes:
``` python
expose_domain_model_subset_as_API, domain_model_mapping_decision, api_complexity
```

> One of the key concepts of domain driven design is low coupling between your different software layers. So, when you design your rest api, you think about the best rest api you could have. Then, it's the role of the application layer to call the domain objects to perform the required use case.

**OPEN CODING TRACE:**
This is about the resource design decision now (lower level) and rather focused on the internal structure, but in
consequence decouples clients from domain model.

benefit: low coupling between your different software layers

**AXIAL CODING TRACE:**

added codes:
``` python
coupling_of_clients_to_server, designing_API_resources_decision,
```
> I can't design your rest api for you, because I don't know what you're trying to do, but here are some ideas.

>As I understand it, you have a Deal resource. As you said, creation/deletion are easy :

>    POST /rest/{version}/deals
>    DELETE /rest/{version}/deals/{id}.

> Then, you want to "hold" a deal. I don't know what that means, you have to think about what it changes in the resource "Deal". Does it change an attribute? if yes, then you're simply modifying the Deal resource.

> PUT /rest/{version}/deals/{id}

>{
>    ...
>    held: true,
>    holdReason: "something",
>    ...
>}

**OPEN CODING TRACE:**

Same as solution 3 above

> Does it add something? Can you have several holds on a Deal? Sounds to me that "hold" is a noun. If it's ugly, find a better noun.

> POST /rest/{version}/deals/{id}/holds

> {
>    reason: "something"
>}

**OPEN CODING TRACE:**
same as Solution 1 above, just the ID of the action is not a verb

> another solution: forget REST theory. If you think your api would be clearer, more efficient, simpler with the use of verbs in the url, then by all means, do it. You can probably find a way to avoid it, but if you can't, don't do something ugly just because it's the norm.

**OPEN CODING TRACE:**
Solution 1 is probably "Action ID appended to URL"

Design Advice: avoid verbs, if possible, but use them when other wording is awkward

-> Rest-specific

> Look at twitter's api: lots of developers say that twitter has a well designed API. Tadaa, it uses verbs! Who cares, as long as it's cool and easy to use?


> I can't design your api for you, you're the only one who knows your use cases, but i'll say again my two advices:

>    Design the rest api by itself, and then use the application layer to call the appropriate domain objects in the right order. That's exactly what the application layer is here for.
>    Don't follow the norms and theories blindly. Yes, you should try to follow good practices and norms as much as possible, but if you can't then leave them behind (after careful consideration of course)

**OPEN CODING TRACE:**
same as above.

# POST 4:

> The article Exposing CQRS Through a RESTful API is a detailed approach addressing your problem. You can check the the prototype API. A few comments:

>    It is a sophisticated approach, so you likely don't need to implement everything from the article: the Event Sourcing concurrency through HTTP's ETag and If-Match is such an "advanced" feature
>    It is an opinionated approach: The DDD command type is sent via the media type header, not via the body. Personally, I find it interesting... but not sure to implement this way though

**OPEN CODING TRACE:**

again relation to CQRS pattern

**AXIAL CODING TRACE:**
already added:
    encode_operations_as_commands_in_the_payload,
    cqrs, eventual_consistency, cqrs_API, cqrs_api_use_cqrs, no_cqrs_API, cqrs_decision,
    cqrs_API_can_use_encode_operations_as_commands_in_the_payload 





# POST 5:

> 

> I separate the use cases (UCs) in 2 groups: commands and queries (CQRS), and I have 2 REST controllers (one for commands and another one for queries). The REST resources doesn't have to be model objects to perform CRUD operations on them as a result of POST/GET/PUT/DELETE. Resources can be whatever object you want. Indeed in DDD you shouldn't expose domain model to the controllers.

> (1) RestApiCommandController: One method per command use case. The REST resource in the URI is the command class name. The method is always POST, because you create the command, and then you execute it through a command bus (a mediator in my case). The request body is a JSON object that maps the command properties (the args of the UC).

> For example: http://localhost:8181/command/asignTaskCommand/

```
@RestController
@RequestMapping("/command")
public class RestApiCommandController {

private final Mediator mediator;    

@Autowired
public RestApiCommandController (Mediator mediator) {
    this.mediator = mediator;
}    

@RequestMapping(value = "/asignTaskCommand/", method = RequestMethod.POST)
public ResponseEntity<?> asignTask ( @RequestBody AsignTaskCommand asignTaskCommand ) {     
    this.mediator.execute ( asigTaskCommand );
    return new ResponseEntity ( HttpStatus.OK );
}
```

> (2) RestApiQueryController: One method per query use case. Here the REST resource in the URI is the DTO object that the query returns (as the element of a collection, or just one alone). The method is always GET, and the params of the query UC are params in the URI.

> For example: http://localhost:8181/query/asignedTask/1

```
@RestController
@RequestMapping("/query")
public class RestApiQueryController {

private final Mediator mediator;    

@Autowired
public RestApiQueryController (Mediator mediator) {
    this.mediator = mediator;
}    

@RequestMapping(value = "/asignedTask/{employeeId}", method = RequestMethod.GET)
public ResponseEntity<List<AsignedTask>> asignedTasksToEmployee ( @PathVariable("employeeId") String employeeId ) {

    AsignedTasksQuery asignedTasksQuery = new AsignedTasksQuery ( employeeId);
    List<AsignedTask> result = mediator.executeQuery ( asignedTasksQuery );
    if ( result==null || result.isEmpty() ) {
        return new ResponseEntity ( HttpStatus.NOT_FOUND );
    }
    return new ResponseEntity<List<AsignedTask>>(result, HttpStatus.OK);
} 
```

> NOTE: Mediator belongs to the DDD application layer. It's the UC boundary, it looks for the command/query, and execute the appropiate application service.
>

**OPEN CODING TRACE:**

This post explains how CQRS can be used in this case. per command identified, introduce one controller and query interface

It shows CQRS is actually an alternative in the design decision 

This is valid: In general for APIs, not only for the REST choices outlined above. The solutions 1, 2, 3 above are rest specific.

**AXIAL CODING TRACE:**
already added:
    encode_operations_as_commands_in_the_payload,
    cqrs, eventual_consistency, cqrs_API, cqrs_api_use_cqrs, no_cqrs_API, cqrs_decision,
    cqrs_API_can_use_encode_operations_as_commands_in_the_payload 
