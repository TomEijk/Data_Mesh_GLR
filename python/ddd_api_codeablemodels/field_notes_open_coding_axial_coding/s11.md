# s 
11
## url
https://medium.com/@shijuvar/microservices-overview-misinterpretations-and-misuses-56a1979edafb
## tiny url
https://tinyurl.com/api-ddd-s11
## archive url
https://bit.ly/3jDLwnF
## title
Microservices: Overview, Misinterpretations and Misuses
## source code
no
## example
ืno
## source type 
Practitioner Audience Article
## author type
Practitioner
## references
- Building Microservices
- Domain-Driven Design: Tackling Complexity in the Heart of Software
  @book{newman2015building,
  title={Building microservices: designing fine-grained systems},
  author={Newman, Sam},
  year={2015},
  publisher={" O'Reilly Media, Inc."}
}

**AXIAL CODING TRACE**: source and references
``` python
s11 = CClass(source, "s11", values={
    "title": "Microservices: Overview, Misinterpretations and Misuses",
    "url": "https://medium.com/@shijuvar/microservices-overview-misinterpretations-and-misuses-56a1979edafb",
    "archive url": "https://bit.ly/3jDLwnF",
    "author type": "Practitioner",
    "type": "Practitioner Audience Article",
    "example": False,
    "source code": False})

building_ms_book_2015 = CClass(reference, "Building Microservice", values={
    "bibliographic reference": "author_name: book_name}" + "publisher, year",
    "author type": "Practitioner",
    "type": "Practitioner Book"})

add_links({s11: [ddd_book_2004, building_ms_book_2015]}, role_name="referenced")
``` 

# coding
> DDD Aggregates and Bounded Context for Decomposition of Microservices
When you’re moving to Microservices architecture from a monolithic architecture, the big question is how to decompose the Microservices. How to broke up a larger software system into functional components?. What’s the size of a Microservice? The answer is very simple: domain modelling. Sam Newman, on his book titled “Building Microservices” says all roads to Microservices pass through domain modelling. The book titled “Domain-Driven Design: Tackling Complexity in the Heart of Software” by Eric Evans, published in 2003, is a classic book on domain modelling, which provides guideline for building complex software systems based on domain model. Ever since the release of this book, the term Domain-Driven Design (DDD), was widely accepted by the community and have been using DDD as the way to build oftware systems. DDD, introduced various building blocks such as Entity, Value Object, Services, Repositories, Aggregates and Bounded Context.

**OPEN CODING TRACE:**
- <ins>Domain Models: </ins> entity,value_object,service,aggregate,repository ,bounded_context

add codes to s11: 
``` python 
    '''
    entity,value_object,service,aggregate,repository ,bounded_context
    '''
```

>[SNIP] intro
>
>
>
>Building Scalable Microservices with Event Sourcing and CQRS

>DDD Aggregates and Bounded Contexts are the foundational building blocks of Microservices, but when you’re going to choose a concrete architecture for building your distributed system to solve practical challenges of Microservices, an event-driven reactive system on DDD aggregates would be a great approach. For this, I highly recommend to use Event Sourcing, which is an event-centric architecture to construct the state of an application by composing various events. Event Sourcing deals with an event store of immutable log of events, in which each log (a state change made to an object) represents an application state. Because every state change in the application, is treated as an immutable log, you can easily troubleshoot the application and can also going back to a particular version of application state at any time. An event store is like a version control system. In a Microservices architecture, we can persist aggregates as a sequence of event. Events are facts, which represent some actions happened in the system. These are immutable, which can’t be changed or be retracted. If you would like to make a change in the system, do persist logs into the event store to represent an another set of events. The example of events are OrderCreated, OrderApproved, OrderShipped, OrderDelivered, etc. In your Event Sourcing architecture, when you publish one event from one Microservice, other Microservices can be reactive to those events and publish another set of events. Sometimes, the sequence of events can be compared with Unix pipes. A single transaction in a Microservices system may span into multiple Microservices where we can perform a transaction as a sequence of events by building reactive Microservices. Each state change of an aggregate can be treated as an event, which is an immutable fact about your system. In order to publish events to let other Microservices know about something has happened in our system, we can use messaging systems like Apcera NATS, Kafka, RabbitMQ, etc. My personal choices are Apcera NATS and Google Cloud Pub/Sub. An event-driven, reactive architecture is a great choice of architecture approach for building massively scalable Microservices.

>When you make persistence as a sequence of events by using an Event Sourcing, you may need an architecture approach to make queries for your Microservices. An architecture pattern, Command Query Responsibility Segregation (CQRS) is an ideal pattern for implementing queries for your Microservices. As the name implies, CQRS segregates an application into two parts: Commands to perform an action to change the state of aggregates, and Queries to provide a query model for the views of aggregates. We may also use different databases for both write operations and query operations. This will also allows you to make highly performant query model by loading denormalised data sets into data stores of read models. NoSQL/NewSQL databases are great options to store the data of read models.

>Although Event Sourcing and CQRS, are great patterns for implementing a distributed system using Microservices architecture, it’s not a silver bullet and it has its own limitations. You may need different architecture style for building some kind of Microservices systems. But generally, I feel that Event Sourcing, paired with CQRS, is a great approach for implementing Microservices systems.
>

**OPEN CODING TRACE:**
CQRS might be introduced in API
Discusses not using it
Mentions its complexity challenges.
Mentions its positive aspects for scalability

**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''
no_cqrs_API, cqrs_API, cqrs_decision, api_complexity, scalability
    '''
```

>
> Inter-Process Communication of Microservices over APIs using gRPC
>In Microservices architecture, you may need to make lot of inter-process communication between Microservices. Here’re the two options you may use to make inter-process communication between Microservices:
Asynchronous event-driven architecture with a messaging system
Build high performance APIs at scale for millions of API calls per second
By using an Event Sourcing architecture with a messaging system, you can implement an asynchronous event-driven architecture to manage the state of aggregates. You may also need to make APIs to communicate between Microservices. When you make APIs to perform inter-process communication between Microservices, performance and scalability are very important things. You should not feel that there are lot of communications are happening over networks by building high performance APIs. When you build massively scalable systems, JSON based RESTful APIs are not a good option because of the performance challenges and the lack of capability to expose domain-specific operations as APIs as RESTful systems are working over the concept of resources. Here, gRPC, a high performance, open-source remote procedure call (RPC) framework, can be used for building massively scalable APIs for the inter-process communication between Microservices. By default, gRPC uses Protocol Buffers as the Interface Definition Language (IDL) and as its underlying message interchange format. gRPC is an open source version of Google’s internal framework, Stubby, which is used to scale 10 billion API calls per second. gRPC can be called as a protocol for inter-process communication in Microservices architecture over APIs.

**OPEN CODING TRACE:**
Discusses forces scalability, performance, chatty_api

Discusses better performance of domain operations on resources compared to crud style operations in REST

**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''
    scalability, performance, chatty_api, crud_style_operations_on_resources, domain_operations_on_resources,
    operation_design_decision, expose_domain_events_as_state_transitions
    '''
```