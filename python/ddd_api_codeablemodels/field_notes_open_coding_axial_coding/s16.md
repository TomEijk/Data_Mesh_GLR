# s 
16
## url
https://www.infoq.com/articles/rest-api-on-cqrs/
## tiny url
https://tinyurl.com/api-ddd-s16
## archive url
https://bit.ly/39gt3J0
## title
Exposing CQRS Through a RESTful API
## source code
yes
## example
yes
- m-r models a simplistic domain of inventory management.
  - https://github.com/aliostad/m-r
  - http://m-r.azurewebsites.net/index.html#/
## source type 
Practitioner Audience Article
## author type
Practitioner
## references
- cqrs document = https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf

**AXIAL CODING TRACE**: source and references
``` python
s16 = CClass(source, "s16", values={
    "title": "Exposing CQRS Through a RESTful API",
    "url": "https://www.infoq.com/articles/rest-api-on-cqrs/",
    "archive url": "https://bit.ly/39gt3J0",
    "author type": "Practitioner",
    "type": "Practitioner Audience Article",
    "example": True,
    "source code": True})
cqrs_document_2010 = CClass(reference, "CQRS Documents by Greg Young", values={
    "bibliographic reference": "Greg Young: https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf " + "cqrsinfo.com, 2010",
    "author type": "Practitioner",
    "type": "Practitioner Book"})
add_links({s16: cqrs_document_2010}, role_name="referenced")
``` 

# coding
> Intro
>
>Command Query Responsibility Segregation (CQRS) is an architectural pattern proposed by Greg Young that segregates reads (queries) and writes (commands) of a system into two separate subsystems. Commands are usually asynchronous and stored in a transactional storage while reads are eventually consistent and retrieved from de-normalised views.

> This article proposes and demonstrates an approach for building a RESTful API on top of CQRS systems. The approach joins HTTP semantics and resource-based style of REST APIs with distributed computing concerns such as eventual consistency and concurrency.

> [...]

**OPEN CODING TRACE:**
- CQRS as an API design option,
- data consistency
- eventual consistency support.

**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''
    cqrs, no_cqrs_API, cqrs_API, cqrs_decision, data_consistency, eventual_consistency_support
    '''
```

> The m-r Domain
> [...]

> m-r implements CQRS: commands and queries are stored separately and are each handled by completely different parts of the system.
>
> On top of CQRS, m-r uses Event Sourcing as its persistence mechanism. In this approach, changes to domain models are captured as a series of events and these events are stored in the order they have been invoked. In order to build the current state of a model, all events need to run in the order they have arrived, in other words, the state of entities are never persisted. For example, if we create an inventory item and rename it twice, we will have one InventoryItemCreated and two InventoryItemRenamed events and they will be stored in the Event Store.
>
>Events are sequential and every event has a version number which can be used for concurrency checks. For example, if an inventory item is renamed against version 2 but another rename had happened against the same item and current version is 3, this will result in a concurrency exception.

> Commands normally have a one-to-one relationship with the Domain Events and after applying the command, the domain model raises an Event to be stored. Domain Event is the cornerstone of Event Sourcing and unlike cross-bounded context events, they are granular and contain the least amount of information required. As such, they are not a great integration tool between different bounded contexts. In addition to an in-process Event Bus, m-r uses an In-Memory Event Store. This store is basically a hashmap using the id of the model as the key and keeps track of the events against the model.

**OPEN CODING TRACE:**
- event sourcing implies eventual consistency
- here domain events and commands (domain operations) are exposed as operations.

**AXIAL CODING TRACE:**
``` python
operation_design_decision, expose_domain_events_as_state_transitions, domain_operations_on_resources
```


> Building a REST API On Top
>... example is provided
> Shaping the public domain

> Resources
It feels natural that we should have an InventoryItem resource so we expose the domain's single root entity as a single resource - conveniently at /api/InventoryItem. Each inventory item will be sitting at /api/InventoryItem/{id} - m-r uses GUIDs for Id.

>This single resource root can fully represent our domain. One alternative is to have /api/InventoryItem/{id}/Stock resource for adding/removing stock (check-in and remove items). ). This per-se does not have any advantage but is just a nicer presentation of the resource. The original approach is simpler and that is what has been used here.

**OPEN CODING TRACE:**
- explains an entity being exposed in an API, CRUD-style

**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''
    entity, entities_as_API_resources, designing_API_resources_decision,
    operation_design_decision, crud_style_operations_on_resources
    '''
```
> Queries
>We have two queries: GetInventoryItems and GetInventoryItemDetails. They are exposed with GET methods at /api/InventoryItem and /api/InventoryItem/{id}.

>GetInventoryItems retrieves a list of only Names and Ids of the items - as JSON or XML depending on the ACCEPT header (this feature comes out of the box in ASP.NET Web API). All GET requests present an opportunity for caching if the resource is suitable for caching. GetInventoryItems returns InventoryItemListDataCollection as the output message. Generating an ETag based on the hash of the content is possible but we can concatenate Ids and Names in the list and send the hash as an ETag to the client (e.g. browser here). The client can cache the resource and make conditional requests using If-Non-Match against the ETag. Resources here are set up to be served with max-age of zero so that the client should always make a conditional GET but we could have equally chosen any arbitrary expiry.


>Notice that the Content-Type header contains extra parameters. This is an implementation of "Five Levels of Media Type" or 5LMT where instead of cramming all information into a single token, we use different parameters to convey different levels of data that can be useful to clients with different level of intelligence. This topic is expanded upon further down.

**OPEN CODING TRACE:**
- details about the query mapping


> Command
> ... mapping http method to the use cases
> Queries naturally map to GET while commands need to be mapped to POST, PUT, DELETE and PATCH. Mapping HTTP verbs to CRUD operations is a popular notion, but in the real world a clean one-to-one mapping between verbs and database operations occurs much less often. In fact, REST API is not a thin shell on top of a persistence store, quite the contrary, it is the door to the richness of the business domain, its operations and workflows. As such it must be able to express such axes of intent without resorting to custom verbs.

> One common approach is using RPC-style resources for example /api/InventoryItem/{id}/rename. While this seemingly removes the need for arbitrary verbs, it is against REST's resource-oriented presentation. We need to be reminded that a resource is a noun and HTTP verb is the verb/action and self-descriptive messages (one of the tenets of REST) are the vehicle to convey other axes of information and intent. In fact the command in the payload of the HTTP message should be enough to express any arbitrary action. However, relying on the body of the message has problems of its own since the body is usually delivered as a stream and buffering the body in its entirety before identifying action is not always possible nor wise. Here we present an approach based on level 4 (domain model) of 5LMT where the command type is presented as a parameter of the Content-Type header:

> This is required to channel the request to the appropriate handler on the server. Is this not leaking too much information over to the clients? Not at all. Schema (and name) of the input and output messages are part of the Public Domain and clients must have full access to and they are expected to take dependency upon the schemas.

> Another important verb to implement is OPTIONS. This verb has a lot of potential to serve API documentation but here we simply return the verb supported at the resource:

**OPEN CODING TRACE:**
- details about the query mapping
- mentions possibility of domain operations on resources and encoding them in the payload.
- discusses aspects of api_understandability such as self-descriptive messages, leaking too much information over to the clients


**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''
     encode_operations_as_commands_in_the_payload, api_understandability
    '''
```

> Discussion
> Concurrency check is optional
> Five Levels of Media Type (5LMT) vs. minting new media types
> Protecting internal domain using a Public Domain is essential

>Conclusion
Exposing a CQRS service through a REST API is not only possible but the richness of HTTP semantics allows for a fluent and efficient API to be built on top. This process involves building a public domain composed of commands, queries (input/output messages) and resources that are concurrency and caching aware. Also we need to map internal domain(s queries and commands to HTTP verbs and use status codes to convey state transitions and exceptions. Use of 5LMT helps with building resources that are fully RESTful and not RPC-styled. All of this has been demonstrated in a minimal but working prototype implemented in ASP.NET Web API and AngularJS.

**OPEN CODING TRACE:**
- mentions again api understandability and performance,  concurrency and caching -> scalability aspects. 

**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''
     performance, scalability
    '''
```

