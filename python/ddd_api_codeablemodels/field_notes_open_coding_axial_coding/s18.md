# s 
18
## url
https://docs.microsoft.com/en-us/azure/architecture/microservices/design/api-design
## tiny url
https://tinyurl.com/api-ddd-s18
## archive url
https://bit.ly/2WL8IpV
## title
Designing APIs for microservices
## source code
yes
## example
yes
## source type 
Practitioner Audience Article
## author type
Practitioner
## references

**AXIAL CODING TRACE**: source and references
``` python
s18 = CClass(source, "s18", values={
    "title": "Designing APIs for microservices",
    "url": "https://docs.microsoft.com/en-us/azure/architecture/microservices/design/api-design",
    "archive url": "https://bit.ly/2WL8IpV",
    "author type": "Practitioner",
    "type": "Practitioner Audience Article",
    "example": True,
    "source code": True})
``` 

# coding

>Good API design is important in a microservices architecture, because all data exchange between services happens either through messages or API calls. APIs must be efficient to avoid creating chatty I/O. Because services are designed by teams working independently, APIs must have well-defined semantics and versioning schemes, so that updates don't break other services.

**OPEN CODING TRACE:**
- chatty API force

**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''
    chatty_api
    '''
```


>It's important to distinguish between two types of API:
Public APIs that client applications call.
Backend APIs that are used for interservice communication.
These two use cases have somewhat different requirements. A public API must be compatible with client applications, typically browser applications or native mobile applications. Most of the time, that means the public API will use REST over HTTP. For the backend APIs, however, you need to take network performance into account. Depending on the granularity of your services, interservice communication can result in a lot of network traffic. Services can quickly become I/O bound. For that reason, considerations such as serialization speed and payload size become more important. Some popular alternatives to using REST over HTTP include gRPC, Apache Avro, and Apache Thrift. These protocols support binary serialization and are generally more efficient than HTTP.

**OPEN CODING TRACE:**
- public vs backend API: new force for contract decision: do we need support for external clients?
- discussing of performance and scalability aspects of the API
- REST (and its CRUD style operations) and domain operations mainly mentioned 
because of the protocols' impact, but mentioned implicitly as options

**AXIAL CODING TRACE:**
added force and force relations:
``` python 
    '''
support_for_external_or_public_clients = CClass(force, "Support for external or public clients")
add_force_relations({api_contract_specified: {separation_of_api_contract_and_domain_concerns: positive,
                                              api_stability: positive,
                                              domain_model_flexibility: positive,
                                              initial_effort_required: neutral,
                                              api_modifiability: neutral,
                                              maintainability_of_api_and_consumers: neutral,
                                              support_for_external_or_public_clients: very_positive
                                              },
                     api_contract_extracted: {separation_of_api_contract_and_domain_concerns: positive,
                                              api_stability: positive,
                                              domain_model_flexibility: positive,
                                              initial_effort_required: neutral,
                                              api_modifiability: neutral,
                                              maintainability_of_api_and_consumers: neutral,
                                              support_for_external_or_public_clients: positive
                                              },
                     domain_model_defines_api_contract: {separation_of_api_contract_and_domain_concerns: negative,
                                                         api_stability: very_negative,
                                                         domain_model_flexibility: very_negative,
                                                         support_for_external_or_public_clients: neutral
                                                         },
                     bounded_context_defines_api_contract: {separation_of_api_contract_and_domain_concerns: negative,
                                                            api_stability: very_negative,
                                                            domain_model_flexibility: very_negative,
                                                            initial_effort_required: neutral,
                                                            api_modifiability: neutral,
                                                            maintainability_of_api_and_consumers: neutral,
                                                            support_for_external_or_public_clients: neutral
                                                            },
                     api_code_first: {separation_of_api_contract_and_domain_concerns: very_negative,
                                      api_stability: very_negative,
                                      domain_model_flexibility: very_negative,
                                      initial_effort_required: very_positive,
                                      api_modifiability: negative,
                                      maintainability_of_api_and_consumers: negative,
                                      support_for_external_or_public_clients: very_negative
                                      }
                     })

    
    '''
```

add codes to s: 
``` python 
    '''
    performance, scalability, crud_style_operations_on_resources, 
    domain_operations_on_resources, operation_design_decision, support_for_external_or_public_clients
    '''
```

>REST versus RPC. Consider the tradeoffs between using a REST-style interface versus an RPC-style interface.

>REST models resources, which can be a natural way express your domain model. It defines a uniform interface based on HTTP verbs, which encourages evolvability. It has well-defined semantics in terms of idempotency, side effects, and response codes. And it enforces stateless communication, which improves scalability.

>RPC is more oriented around operations or commands. Because RPC interfaces look like local method calls, it may lead you to design overly chatty APIs. However, that doesn't mean RPC must be chatty. It just means you need to use care when designing the interface.

>For a RESTful interface, the most common choice is REST over HTTP using JSON. For an RPC-style interface, there are several popular frameworks, including gRPC, Apache Avro, and Apache Thrift.

**OPEN CODING TRACE:**
- again domain operations vs. CRUD style, chatty API plus api evolvability,
    apimodifiability, scalability forces

**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''
    api_evolvability, api_modifiability
    '''
```
>Efficiency. Consider efficiency in terms of speed, memory, and payload size. Typically a gRPC-based interface is faster than REST over HTTP.

**OPEN CODING TRACE:**
- again  scalability, performance aspects


> Interface definition language (IDL). An IDL is used to define the methods, parameters, and return values of an API. An IDL can be used to generate client code, serialization code, and API documentation. IDLs can also be consumed by API testing tools such as Postman. Frameworks such as gRPC, Avro, and Thrift define their own IDL specifications. REST over HTTP does not have a standard IDL format, but a common choice is OpenAPI (formerly Swagger). You can also create an HTTP REST API without using a formal definition language, but then you lose the benefits of code generation and testing.

**OPEN CODING TRACE:**
- options for the API contract in REST/RPC


**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''
       api_as_contract_decision, api_contract_specified, api_contract_extracted,
    '''
```

>Compatibility and interoperability. If you choose a protocol like gRPC, you may need a protocol translation layer between the public API and the back end. A gateway can perform that function. If you are using a service mesh, consider which protocols are compatible with the service mesh. For example, linkerd has built-in support for HTTP, Thrift, and gRPC.

>Our baseline recommendation is to choose REST over HTTP unless you need the performance benefits of a binary protocol. REST over HTTP requires no special libraries. It creates minimal coupling, because callers don't need a client stub to communicate with the service. There is rich ecosystems of tools to support schema definitions, testing, and monitoring of RESTful HTTP endpoints. Finally, HTTP is compatible with browser clients, so you don't need a protocol translation layer between the client and the backend.

>However, if you choose REST over HTTP, you should do performance and load testing early in the development process, to validate whether it performs well enough for your scenario.

**OPEN CODING TRACE:**
only on protocol specific aspects


> RESTful API design
> Watch out for APIs that leak internal implementation details or simply mirror an internal database schema. The API should model the domain. It's a contract between services, and ideally should only change when new functionality is added, not just because you refactored some code or normalized a database table.

**OPEN CODING TRACE:**
The API should model the domain.

**AXIAL CODING TRACE:**
already added:    api_as_contract_decision, domain_model_defines_api_contract

> Different types of client, such as mobile application and desktop web browser, may require different payload sizes or interaction patterns. Consider using the Backends for Frontends pattern to create separate backends for each client, that expose an optimal interface for that client.

**OPEN CODING TRACE:**
Backends for Frontends is relevant for API design, but really DDD related

>For operations with side effects, consider making them idempotent and implementing them as PUT methods. That will enable safe retries and can improve resiliency. The article Interservice communication discuss this issue in more detail.

>HTTP methods can have asynchronous semantics, where the method returns a response immediately, but the service carries out the operation asynchronously. In that case, the method should return an HTTP 202 response code, which indicates the request was accepted for processing, but the processing is not yet completed. For more information, see Asynchronous Request-Reply pattern.

**OPEN CODING TRACE:**
details on REST specifics

> Mapping REST to DDD patterns
> Patterns such as entity, aggregate, and value object are designed to place certain constraints on the objects in your domain model. In many discussions of DDD, the patterns are modeled using object-oriented (OO) language concepts like constructors or property getters and setters. For example, value objects are supposed to be immutable. In an OO programming language, you would enforce this by assigning the values in the constructor and making the properties read-only:
```
export class Location {
    readonly latitude: number;
    readonly longitude: number;

    constructor(latitude: number, longitude: number) {
        if (latitude < -90 || latitude > 90) {
            throw new RangeError('latitude must be between -90 and 90');
        }
        if (longitude < -180 || longitude > 180) {
            throw new RangeError('longitude must be between -180 and 180');
        }
        this.latitude = latitude;
        this.longitude = longitude;
    }
}
```
**OPEN CODING TRACE:**
options of using entities and aggregates as API resources, and then how a value object 
can be exposed in them.


**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''
    entity, aggregate, value_object, designing_API_resources_decision, entities_as_API_resources, aggregate_roots_as_API_resources, 
    ''
```
> For these reasons, this guidance doesn't focus much on coding practices as they relate to the tactical DDD patterns. But it turns out that you can also model many of the DDD patterns through REST APIs.

**OPEN CODING TRACE:**
coding practices -> tactical DDD patterns

>Aggregates map naturally to resources in REST. For example, the Delivery aggregate would be exposed as a resource by the Delivery API.

>Aggregates are consistency boundaries. Operations on aggregates should never leave an aggregate in an inconsistent state. Therefore, you should avoid creating APIs that allow a client to manipulate the internal state of an aggregate. Instead, favor coarse-grained APIs that expose aggregates as resources.

**OPEN CODING TRACE:**
- positive aspects of aggregates as resources
- hiding domain model details, data consistency, reduce complexity, (coarse grained API),
coupling client to server (you should avoid creating APIs that allow a client to manipulate the internal state of an aggregate.)


**AXIAL CODING TRACE:**
add codes to s: 
``` python 
    '''
    expose_domain_model_details_in_api, data_consistency, api_complexity,
    coupling_of_clients_to_server
    '''

```
>Entities have unique identities. In REST, resources have unique identifiers in the form of URLs. Create resource URLs that correspond to an entity's domain identity. The mapping from URL to domain identity may be opaque to client.

>Child entities of an aggregate can be reached by navigating from the root entity. If you follow HATEOAS principles, child entities can be reached via links in the representation of the parent entity.

**OPEN CODING TRACE:**
- distributed links and passing of objects ids

**AXIAL CODING TRACE:**
add codes to s: 
``` python 
'''
link_mapping_decision, use_distributed_links, pass_object_ids
'''
```
>Because value objects are immutable, updates are performed by replacing the entire value object. In REST, implement updates through PUT or PATCH requests.

>A repository lets clients query, add, or remove objects in a collection, abstracting the details of the underlying data store. In REST, a collection can be a distinct resource, with methods for querying the collection or adding new entities to the collection.

**AXIAL CODING TRACE:**
again  crud_style_operations_on_resources details, nothing added

> API versioning
> An API is a contract between a service and clients or consumers of that service.
> [SNIP]... 

**AXIAL CODING TRACE:**
api_as_contract_decision mentined again.

>Idempotent operations
>The HTTP specification states that GET, PUT, and DELETE methods must be idempotent. POST methods are not guaranteed to be idempotent. If a POST method creates a new resource, there is generally no guarantee that this operation is idempotent. The specification defines idempotent this way:

**OPEN CODING TRACE:**
no new codes